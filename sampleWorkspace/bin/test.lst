ca65 V2.18 - fastbasic-4.6
Main file   : test.asm
Current file: test.asm

000000r 1               ; Imported symbols
000000r 1               	.globalzp IOERROR
000000r 1               
000000r 1               ; Exported symbols
000000r 1               	.export bytecode_start
000000r 1               
000000r 1               	.include "target.inc"
000000r 2               ;
000000r 2               ; FastBasic - Fast basic interpreter for the Atari 8-bit computers
000000r 2               ; Copyright (C) 2017-2022 Daniel Serpell
000000r 2               ;
000000r 2               ; This program is free software; you can redistribute it and/or modify
000000r 2               ; it under the terms of the GNU General Public License as published by
000000r 2               ; the Free Software Foundation, either version 2 of the License, or
000000r 2               ; (at your option) any later version.
000000r 2               ;
000000r 2               ; This program is distributed in the hope that it will be useful,
000000r 2               ; but WITHOUT ANY WARRANTY; without even the implied warranty of
000000r 2               ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
000000r 2               ; GNU General Public License for more details.
000000r 2               ;
000000r 2               ; You should have received a copy of the GNU General Public License along
000000r 2               ; with this program.  If not, see <http://www.gnu.org/licenses/>
000000r 2               ;
000000r 2               
000000r 2               ; Assembly include file depending on the target
000000r 2               ; ---------------------------------------------
000000r 2               
000000r 2               .ifdef __ATARI5200__
000000r 2                .include  "atari5200.inc"
000000r 2                .global   MEMTOP, GPRIOR
000000r 2                .globalzp COLCRS, ROWCRS
000000r 2               .else
000000r 2                .include  "atari.inc"
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Atari System Equates
000000r 3               ; by Freddy Offenga, Christian Groessler, and Christian Krueger
000000r 3               ;
000000r 3               ; References:
000000r 3               ; - Atari 400/800 OS rev.B source code, Atari 1979
000000r 3               ; - Atari OS manual - XL addendum
000000r 3               ; - Atari XL/XE rev.2 source code, Atari 1984
000000r 3               ; - Mapping the Atari - revised edition, Ian Chadwick 1985
000000r 3               ; - SpartaDOS-X User Guide  (Aug-8-2016)
000000r 3               ;
000000r 3               ; ##old##       old OS rev.B label - moved or deleted
000000r 3               ; ##1200xl##    new label introduced in 1200XL OS (rev.10/11)
000000r 3               ; ##rev2##      new label introduced in XL/XE OS rev.2
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Configuration Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               MAXDEV  = 33            ;offset to last possible entry of HATABS
000000r 3               IOCBSZ  = 16            ;length of IOCB
000000r 3               
000000r 3               SEIOCB  = 0*IOCBSZ      ;##rev2## screen editor IOCB index
000000r 3               MAXIOC  = 8*IOCBSZ      ;first invalid IOCB index
000000r 3               
000000r 3               DSCTSZ  = 128           ;##rev2## disk sector size
000000r 3               
000000r 3               LEDGE   = 2             ;left edge
000000r 3               REDGE   = 39            ;right edge
000000r 3               
000000r 3               INIML   = $0700         ;##rev2## initial MEMLO
000000r 3               
000000r 3               ICSORG  = $CC00         ;##rev2## international character set origin
000000r 3               DCSORG  = $E000         ;##rev2## domestic character set origin
000000r 3               
000000r 3               ; IOCB Command Code Equates
000000r 3               
000000r 3               OPEN    = $03           ;open
000000r 3               GETREC  = $05           ;get record
000000r 3               GETCHR  = $07           ;get character(s)
000000r 3               PUTREC  = $09           ;put record
000000r 3               PUTCHR  = $0B           ;put character(s)
000000r 3               CLOSE   = $0C           ;close
000000r 3               STATIS  = $0D           ;status
000000r 3               SPECIL  = $0E           ;special
000000r 3               
000000r 3               ; DOS IOCB command codes
000000r 3               
000000r 3               RENAME  = $20           ;rename disk file
000000r 3               DELETE  = $21           ;delete disk file
000000r 3               LOCKFL  = $23           ;lock file (set to read-only)
000000r 3               UNLOCK  = $24           ;unlock file
000000r 3               POINT   = $25           ;point sector
000000r 3               NOTE    = $26           ;note sector
000000r 3               GETFL   = $27           ;get file length
000000r 3               CHDIR_MYDOS     = $29   ;change directory (MyDOS)
000000r 3               MKDIR   = $2A           ;make directory (MyDOS/SpartaDOS)
000000r 3               RMDIR   = $2B           ;remove directory (SpartaDOS)
000000r 3               CHDIR_SPDOS     = $2C   ;change directory (SpartaDOS)
000000r 3               FORMAT  = $FE           ;format
000000r 3               
000000r 3               GETCWD  = $30           ;get current directory (MyDOS/SpartaDOS)
000000r 3               
000000r 3               ; Special Entry Command Equates
000000r 3               ; DOS Commands
000000r 3               ; Command line table, Index values for (DOSVEC),Y -- COMTAB
000000r 3               ; Compatible with OS/A+, DOS XL and SpartaDOS
000000r 3               
000000r 3               COMTAB  = 0             ;DOS entry jump vector
000000r 3               ZCRNAME = 3             ;file name crunch routine jump vector
000000r 3               BUFOFF  = 10            ;next parameter buffer offset
000000r 3               COMFNAM = 33            ;destination buffer for crunch routine
000000r 3               LBUF    = 63            ;command line input buffer
000000r 3               
000000r 3               ; Screen IOCB Commands
000000r 3               
000000r 3               DRAWLN  = $11           ;draw line
000000r 3               FILLIN  = $12           ;draw line with right fill
000000r 3               
000000r 3               ; ICAX1 Auxiliary Byte 1 Equates
000000r 3               
000000r 3               APPEND  = $01           ;open write append (D:)
000000r 3               DIRECT  = $02           ;open for directory access (D:)
000000r 3               OPNIN   = $04           ;open for input (all devices)
000000r 3               OPNOT   = $08           ;open for output (all devices)
000000r 3               MXDMOD  = $10           ;open for mixed mode (E:, S:)
000000r 3               INSCLR  = $20           ;open for input without clearing screen
000000r 3               
000000r 3               ; Device Code Equates
000000r 3               
000000r 3               CASSET  = 'C'           ;cassette
000000r 3               DISK    = 'D'           ;disk
000000r 3               SCREDT  = 'E'           ;screen editor
000000r 3               KBD     = 'K'           ;keyboard
000000r 3               PRINTR  = 'P'           ;printer
000000r 3               DISPLY  = 'S'           ;screen display
000000r 3               
000000r 3               ; SIO Command Code Equates
000000r 3               
000000r 3               SIO_FORMAT   = $21      ;format disk (default density)
000000r 3               SIO_FORMATS  = $22      ;1050: format medium density
000000r 3               SIO_CONFIG   = $44      ;configure drive
000000r 3               SIO_CONFIGSF = $4B      ;slow/fast configure drive??
000000r 3               SIO_RDPERCOM = $4E      ;read PERCOM block (XF551)
000000r 3               SIO_WRPERCOM = $4F      ;write PERCOM block (XF551)
000000r 3               SIO_WRITE    = $50      ;write sector
000000r 3               SIO_READ     = $52      ;read sector
000000r 3               SIO_STAT     = $53      ;get status information
000000r 3               SIO_VERIFY   = $56      ;verify sector
000000r 3               SIO_WRITEV   = $57      ;write sector with verify
000000r 3               SIO_WRITETRK = $60      ;write track (Speedy)
000000r 3               SIO_READTRK  = $62      ;read track (Speedy)
000000r 3               
000000r 3               ; SIO Status Code (DSTATS)
000000r 3               ; Input: data direction
000000r 3               ;     Bit #7 - W (write operation)
000000r 3               ;         #6 - R (read operation)
000000r 3               ; Output: status code
000000r 3               ;     $01 (001) -- OPERATION COMPLETE (NO ERRORS)
000000r 3               ;     $8A (138) -- DEVICE TIMEOUT (DOESN'T RESPOND)
000000r 3               ;     $8B (139) -- DEVICE NAK
000000r 3               ;     $8C (140) -- SERIAL BUS INPUT FRAMING ERROR
000000r 3               ;     $8E (142) -- SERIAL BUS DATA FRAME OVERRUN ERROR
000000r 3               ;     $8F (143) -- SERIAL BUS DATA FRAME CHECKSUM ERROR
000000r 3               ;     $90 (144) -- DEVICE DONE ERROR
000000r 3               
000000r 3               ; Character and Key Code Equates
000000r 3               
000000r 3               CLS     = $7D           ;##rev2## clear screen
000000r 3               EOL     = $9B           ;end of line (RETURN)
000000r 3               
000000r 3               HELP    = $11           ;##1200xl## key code for HELP
000000r 3               CNTLF1  = $83           ;##1200xl## key code for CTRL-F1
000000r 3               CNTLF2  = $84           ;##1200xl## key code for CTRL-F2
000000r 3               CNTLF3  = $93           ;##1200xl## key code for CTRL-F3
000000r 3               CNTLF4  = $94           ;##1200xl## key code for CTRL-F4
000000r 3               CNTL1   = $9F           ;##1200xl## key code for CTRL-1
000000r 3               
000000r 3               ; Status Code Equates
000000r 3               
000000r 3               SUCCES  = 1             ;($01) succesful operation
000000r 3               
000000r 3               BRKABT  = 128           ;($80) BREAK key abort
000000r 3               PRVOPN  = 129           ;($81) IOCB already open error
000000r 3               NONDEV  = 130           ;($82) nonexistent device error
000000r 3               WRONLY  = 131           ;($83) IOCB opened for write only error
000000r 3               NVALID  = 132           ;($84) invalid command error
000000r 3               NOTOPN  = 133           ;($85) device/file not open error
000000r 3               BADIOC  = 134           ;($86) invalid IOCB index error
000000r 3               RDONLY  = 135           ;($87) IOCB opened for read only error
000000r 3               EOFERR  = 136           ;($88) end of file error
000000r 3               TRNRCD  = 137           ;($89) truncated record error
000000r 3               TIMOUT  = 138           ;($8A) peripheral device timeout error
000000r 3               DNACK   = 139           ;($8B) device does not acknowledge command
000000r 3               FRMERR  = 140           ;($8C) serial bus framing error
000000r 3               CRSROR  = 141           ;($8D) cursor overrange error
000000r 3               OVRRUN  = 142           ;($8E) serial bus data overrun error
000000r 3               CHKERR  = 143           ;($8F) serial bus checksum error
000000r 3               DERROR  = 144           ;($90) device done (operation incomplete)
000000r 3               BADMOD  = 145           ;($91) bad screen mode number error
000000r 3               FNCNOT  = 146           ;($92) function not implemented in handler
000000r 3               SCRMEM  = 147           ;($93) insufficient memory for screen mode
000000r 3               
000000r 3               DSKFMT  = 148           ;($94) SpartaDOS: unrecognized disk format
000000r 3               INCVER  = 149           ;($95) SpartaDOS: disk was made with incompat. version
000000r 3               DIRNFD  = 150           ;($96) SpartaDOS: directory not found
000000r 3               FEXIST  = 151           ;($97) SpartaDOS: file exists
000000r 3               NOTBIN  = 152           ;($98) SpartaDOS: file not binary
000000r 3               LSYMND  = 154           ;($9A) SDX: loader symbol not defined
000000r 3               BADPRM  = 156           ;($9C) SDX: bad parameter
000000r 3               OUTOFM  = 158           ;($9E) SDX: out of memory
000000r 3               INVDEV  = 160           ;($A0) invalid device number
000000r 3               TMOF    = 161           ;($A1) too many open files
000000r 3               DSKFLL  = 162           ;($A2) disk full
000000r 3               FATLIO  = 163           ;($A3) fatal I/O error
000000r 3               FNMSMT  = 164           ;($A4) internal file number mismatch
000000r 3               INVFNM  = 165           ;($A5) invalid file name
000000r 3               PDLERR  = 166           ;($A6) point data length error
000000r 3               EPERM   = 167           ;($A7) permission denied
000000r 3               DINVCM  = 168           ;($A8) command invalid for disk
000000r 3               DIRFLL  = 169           ;($A9) directory full
000000r 3               FNTFND  = 170           ;($AA) file not found
000000r 3               PNTINV  = 171           ;($AB) point invalid
000000r 3               BADDSK  = 173           ;($AD) bad disk
000000r 3               INCFMT  = 176           ;($B0) DOS 3: incompatible file system
000000r 3               XNTBIN  = 180           ;($B4) XDOS: file not binary
000000r 3               
000000r 3               ; DCB Device Bus Equates
000000r 3               
000000r 3               DISKID  = $31           ;##rev2## disk bus ID
000000r 3               PDEVN   = $40           ;##rev2## printer bus ID
000000r 3               CASET   = $60           ;##rev2## cassette bus ID
000000r 3               
000000r 3               ; Bus Command Equates
000000r 3               
000000r 3               FOMAT   = '!'           ;##rev2## format command
000000r 3               PUTSEC  = 'P'           ;##rev2## put sector command
000000r 3               READ    = 'R'           ;##rev2## read command
000000r 3               STATC   = 'S'           ;##rev2## status command
000000r 3               WRITE   = 'W'           ;##rev2## write command
000000r 3               
000000r 3               ; Command Auxiliary Byte Equates
000000r 3               
000000r 3               DOUBLE  = 'D'           ;##rev2## print 20 characters double width
000000r 3               NORMAL  = 'N'           ;##rev2## print 40 characters normally
000000r 3               PLOT    = 'P'           ;##rev2## plot
000000r 3               SIDWAY  = 'S'           ;##rev2## print 16 characters sideways
000000r 3               
000000r 3               ; Bus Response Equates
000000r 3               
000000r 3               ACK     = 'A'           ;##rev2## device acknowledged
000000r 3               COMPLT  = 'C'           ;##rev2## device succesfully completed operation
000000r 3               ERROR   = 'E'           ;##rev2## device incurred error
000000r 3               NACK    = 'N'           ;##rev2## device did not understand
000000r 3               
000000r 3               ; Floating Point Miscellaneous Equates
000000r 3               
000000r 3               FPREC   = 6             ;precision
000000r 3               
000000r 3               FMPREC  = FPREC-1       ;##rev2## length of mantissa
000000r 3               
000000r 3               ; Cassette Record Type Equates
000000r 3               
000000r 3               HDR     = $FB           ;##rev2## header
000000r 3               DTA     = $FC           ;##rev2## data record
000000r 3               DT1     = $FA           ;##rev2## last data record
000000r 3               EOT     = $FE           ;##rev2## end of tape (file)
000000r 3               
000000r 3               TONE1   = 2             ;##rev2## record
000000r 3               TONE2   = 1             ;##rev2## playback
000000r 3               
000000r 3               ; Cassette Timing Equates
000000r 3               
000000r 3               WLEADN  = 1152          ;##rev2## NTSC 19.2 second WRITE file leader
000000r 3               RLEADN  = 576           ;##rev2## NTSC 9.6 second READ file leader
000000r 3               WIRGLN  = 180           ;##rev2## NTSC 3.0 second WRITE IRG
000000r 3               RIRGLN  = 120           ;##rev2## NTSC 2.0 second READ IRG
000000r 3               WSIRGN  = 15            ;##rev2## NTSC 0.25 second WRITE short IRG
000000r 3               RSIRGN  = 10            ;##rev2## NTSC 0.16 second READ short IRG
000000r 3               BEEPNN  = 30            ;##rev2## NTSC 0.5 second beep duration
000000r 3               BEEPFN  = 10            ;##rev2## NTSC 0.16 seconrd beep duration
000000r 3               
000000r 3               WLEADP  = 960           ;##rev2## PAL 19.2 second WRITE file leader
000000r 3               RLEADP  = 480           ;##rev2## PAL 9.6 second READ file leader
000000r 3               WIRGLP  = 150           ;##rev2## PAL 3.0 second WRITE IRG
000000r 3               RIRGLP  = 100           ;##rev2## PAL 2.0 second READ IRG
000000r 3               WSIRGP  = 13            ;##rev2## PAL 0.25 second WRITE short IRG
000000r 3               RSIRGP  = 8             ;##rev2## PAL 0.16 second READ short IRG
000000r 3               BEEPNP  = 25            ;##rev2## PAL 0.5 second beep duration
000000r 3               BEEPFP  = 8             ;##rev2## PAL 0.16 seconrd beep duration
000000r 3               
000000r 3               WIRGHI  = 0             ;##rev2## high WRITE IRG
000000r 3               RIRGHI  = 0             ;##rev2## high READ IRG
000000r 3               
000000r 3               ; Power-up Validation Byte Value Equates
000000r 3               
000000r 3               PUPVL1  = $5C           ;##rev2## power-up validation value 1
000000r 3               PUPVL2  = $93           ;##rev2## power-up validation value 2
000000r 3               PUPVL3  = $25           ;##rev2## power-up validation value 3
000000r 3               
000000r 3               ; Relocating Loader Miscellaneous Equates
000000r 3               
000000r 3               DATAER  = 156           ;##rev2## end of record appears before END
000000r 3               MEMERR  = 157           ;##rev2## memory insufficient for load error
000000r 3               
000000r 3               ; Miscellaneous Equates
000000r 3               
000000r 3               IOCFRE  = $FF           ;IOCB free indication
000000r 3               
000000r 3               B19200  = $0028         ;##rev2## 19200 baud POKEY counter value
000000r 3               B00600  = $05CC         ;##rev2## 600 baud POKEY counter value
000000r 3               
000000r 3               HITONE  = $05           ;##rev2## FSK high freq. POKEY counter value
000000r 3               LOTONE  = $07           ;##rev2## FSK low freq. POKEY counter value
000000r 3               
000000r 3               NCOMLO  = $34           ;##rev2## PIA lower NOT COMMAND line command
000000r 3               NCOMHI  = $3C           ;##rev2## PIA raise NOT COMMAND line command
000000r 3               
000000r 3               MOTRGO  = $34           ;##rev2## PIA cassette motor ON command
000000r 3               MOTRST  = $3C           ;##rev2## PIA cassette motor OFF command
000000r 3               
000000r 3               NODAT   = $00           ;##rev2## SIO immediate operation
000000r 3               GETDAT  = $40           ;##rev2## SIO read data frame
000000r 3               PUTDAT  = $80           ;##rev2## SIO write data frame
000000r 3               
000000r 3               CRETRI  = 13            ;##rev2## number of command frame retries
000000r 3               DRETRI  = 1             ;##rev2## number of device retries
000000r 3               CTIM    = 2             ;##rev2## command frame ACK timeout
000000r 3               
000000r 3               NBUFSZ  = 40            ;##rev2## print normal buffer size
000000r 3               DBUFSZ  = 20            ;##rev2## print double buffer size
000000r 3               SBUFSZ  = 29            ;##rev2## print sideways buffer size
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Page Zero Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               LINZBS  = $00           ;LINBUG RAM (WILL BE REPLACED BY MONITOR RAM)
000000r 3               LNFLG   = $00           ;##1200xl## 1-byte LNBUG flag (0 = not LNBUG)
000000r 3               NGFLAG  = $01           ;##1200xl## 1-byte memory status (0 = failure)
000000r 3               
000000r 3               ; Not Cleared
000000r 3               
000000r 3               CASINI  = $02           ;CASSETTE INIT LOCATION
000000r 3               RAMLO   = $04           ;RAM POINTER FOR MEMORY TEST
000000r 3               TRAMSZ  = $06           ;TEMPORARY REGISTER FOR RAM SIZE
000000r 3               ;TSTDAT = $07           ;##old## RAM TEST DATA REGISTER
000000r 3               CMCMD   = $07           ;##rev2## 1-byte command communications
000000r 3               
000000r 3               ; Cleared upon Coldstart only
000000r 3               
000000r 3               WARMST  = $08           ;WARM START FLAG
000000r 3               BOOTQ   = $09           ;SUCCESSFUL BOOT FLAG
000000r 3               DOSVEC  = $0A           ;DISK SOFTWARE START VECTOR
000000r 3               DOSINI  = $0C           ;DISK SOFTWARE INIT ADDRESS
000000r 3               APPMHI  = $0E           ;APPLICATIONS MEMORY HI LIMIT
000000r 3               
000000r 3               ; Cleared upon Coldstart or Warmstart
000000r 3               
000000r 3               INTZBS  = $10           ;INTERRUPT HANDLER
000000r 3               
000000r 3               POKMSK  = $10           ;SYSTEM MASK FOR POKEY IRQ ENABLE (shadow of IRQEN)
000000r 3               BRKKEY  = $11           ;BREAK KEY FLAG
000000r 3               RTCLOK  = $12           ;REAL TIME CLOCK (IN 16 MSEC UNITS>
000000r 3               BUFADR  = $15           ;INDIRECT BUFFER ADDRESS REGISTER
000000r 3               ICCOMT  = $17           ;COMMAND FOR VECTOR
000000r 3               DSKFMS  = $18           ;DISK FILE MANAGER POINTER
000000r 3               DSKUTL  = $1A           ;DISK UTILITIES POINTER
000000r 3               ABUFPT  = $1C           ;##1200xl## 4-byte ACMI buffer pointer area
000000r 3               
000000r 3               ;PTIMOT = $1C           ;##old## PRINTER TIME OUT REGISTER
000000r 3               ;PBPNT  = $1D           ;##old## PRINT BUFFER POINTER
000000r 3               ;PBUFSZ = $1E           ;##old## PRINT BUFFER SIZE
000000r 3               ;PTEMP  = $1F           ;##old## TEMPORARY REGISTER
000000r 3               
000000r 3               ZIOCB   = $20           ;ZERO PAGE I/O CONTROL BLOCK
000000r 3               IOCBAS  = $20           ;16-byte page zero IOCB
000000r 3               ICHIDZ  = $20           ;HANDLER INDEX NUMBER (FF = IOCB FREE)
000000r 3               ICDNOZ  = $21           ;DEVICE NUMBER (DRIVE NUMBER)
000000r 3               ICCOMZ  = $22           ;COMMAND CODE
000000r 3               ICSTAZ  = $23           ;STATUS OF LAST IOCB ACTION
000000r 3               ICBALZ  = $24           ;BUFFER ADDRESS LOW BYTE
000000r 3               ICBAHZ  = $25           ;1-byte high buffer address
000000r 3               ICPTLZ  = $26           ;PUT BYTE ROUTINE ADDRESS -1
000000r 3               ICPTHZ  = $27           ;1-byte high PUT-BYTE routine address
000000r 3               ICBLLZ  = $28           ;BUFFER LENGTH LOW BYTE
000000r 3               ICBLHZ  = $29           ;1-byte high buffer length
000000r 3               ICAX1Z  = $2A           ;AUXILIARY INFORMATION FIRST BYTE
000000r 3               ICAX2Z  = $2B           ;1-byte second auxiliary information
000000r 3               ICSPRZ  = $2C           ;4-byte spares
000000r 3               
000000r 3               ENTVEC  = $2C           ;##rev2## 2-byte (not used)
000000r 3               ICIDNO  = $2E           ;IOCB NUMBER X 16
000000r 3               CIOCHR  = $2F           ;CHARACTER BYTE FOR CURRENT OPERATION
000000r 3               
000000r 3               STATUS  = $30           ;INTERNAL STATUS STORAGE
000000r 3               CHKSUM  = $31           ;CHECKSUM (SINGLE BYTE SUM WITH CARRY)
000000r 3               BUFRLO  = $32           ;POINTER TO DATA BUFFER (LO BYTE)
000000r 3               BUFRHI  = $33           ;POINTER TO DATA BUFFER (HI BYTE)
000000r 3               BFENLO  = $34           ;NEXT BYTE PAST END OF THE DATA BUFFER LO
000000r 3               BFENHI  = $35           ;NEXT BYTE PAST END OF THE DATA BUFFER HI
000000r 3               ;CRETRY = $36           ;##old## NUMBER OF COMMAND FRAME RETRIES
000000r 3               ;DRETRY = $37           ;##old## NUMBER OF DEVICE RETRIES
000000r 3               LTEMP   = $36           ;##1200xl## 2-byte loader temporary
000000r 3               BUFRFL  = $38           ;DATA BUFFER FULL FLAG
000000r 3               RECVDN  = $39           ;RECEIVE DONE FLAG
000000r 3               XMTDON  = $3A           ;TRANSMISSION DONE FLAG
000000r 3               CHKSNT  = $3B           ;CHECKSUM SENT FLAG
000000r 3               NOCKSM  = $3C           ;NO CHECKSUM FOLLOWS DATA FLAG
000000r 3               BPTR    = $3D           ;1-byte cassette buffer pointer
000000r 3               FTYPE   = $3E           ;1-byte cassette IRG type
000000r 3               FEOF    = $3F           ;1-byte cassette EOF flag (0 = quiet)
000000r 3               FREQ    = $40           ;1-byte cassette beep counter
000000r 3               SOUNDR  = $41           ;NOISY I/0 FLAG. (ZERO IS QUIET)
000000r 3               
000000r 3               CRITIC  = $42           ;DEFINES CRITICAL SECTION (CRITICAL IF NON-Z)
000000r 3               
000000r 3               FMSZPG  = $43           ;DISK FILE MANAGER SYSTEM ZERO PAGE
000000r 3               
000000r 3               ;CKEY   = $4A           ;##old## FLAG SET WHEN GAME START PRESSED
000000r 3               ZCHAIN  = $4A           ;##1200xl## 2-byte handler linkage chain pointer
000000r 3               ;CASSBT = $4B           ;##old## CASSETTE BOOT FLAG
000000r 3               DSTAT   = $4C           ;DISPLAY STATUS
000000r 3               ATRACT  = $4D           ;ATRACT FLAG
000000r 3               DRKMSK  = $4E           ;DARK ATRACT MASK
000000r 3               COLRSH  = $4F           ;ATRACT COLOR SHIFTER (EOR'ED WITH PLAYFIELD
000000r 3               
000000r 3               
000000r 3               TMPCHR  = $50           ;1-byte temporary character
000000r 3               HOLD1   = $51           ;1-byte temporary
000000r 3               LMARGN  = $52           ;left margin (normally 2, cc65 C startup code sets it to 0)
000000r 3               RMARGN  = $53           ;right margin (normally 39 if no XEP80 is used)
000000r 3               ROWCRS  = $54           ;1-byte cursor row
000000r 3               COLCRS  = $55           ;2-byte cursor column
000000r 3               DINDEX  = $57           ;1-byte display mode
000000r 3               SAVMSC  = $58           ;2-byte saved memory scan counter
000000r 3               OLDROW  = $5A           ;1-byte prior row
000000r 3               OLDCOL  = $5B           ;2-byte prior column
000000r 3               OLDCHR  = $5D           ;DATA UNDER CURSOR
000000r 3               OLDADR  = $5E           ;2-byte saved cursor memory address
000000r 3               FKDEF   = $60           ;##1200xl## 2-byte function key definition table
000000r 3               ;NEWROW = $60           ;##old## POINT DRAW GOES TO
000000r 3               ;NEWCOL = $61           ;##old##
000000r 3               PALNTS  = $62           ;##1200xl## 1-byte PAL/NTSC indicator (0 = NTSC)
000000r 3               LOGCOL  = $63           ;POINTS AT COLUMN IN LOGICAL LINE
000000r 3               ADRESS  = $64           ;2-byte temporary address
000000r 3               
000000r 3               MLTTMP  = $66           ;1-byte temporary
000000r 3               OPNTMP  = $66           ;FIRST BYTE IS USED IN OPEN AS TEMP
000000r 3               TOADR   = $66           ;##rev2## 2-byte destination address
000000r 3               
000000r 3               SAVADR  = $68           ;2-byte saved address
000000r 3               FRMADR  = $68           ;##rev2## 2-byte source address
000000r 3               
000000r 3               RAMTOP  = $6A           ;RAM SIZE DEFINED BY POWER ON LOGIC
000000r 3               BUFCNT  = $6B           ;BUFFER COUNT
000000r 3               BUFSTR  = $6C           ;EDITOR GETCH POINTER
000000r 3               BITMSK  = $6E           ;BIT MASK
000000r 3               SHFAMT  = $6F           ;1-byte shift amount for pixel justifucation
000000r 3               ROWAC   = $70           ;2-byte draw working row
000000r 3               COLAC   = $72           ;2-byte draw working column
000000r 3               ENDPT   = $74           ;2-byte end point
000000r 3               DELTAR  = $76           ;1-byte row difference
000000r 3               DELTAC  = $77           ;2-byte column difference
000000r 3               KEYDEF  = $79           ;##1200xl## 2-byte key definition table address
000000r 3               ;ROWINC = $79           ;##old##
000000r 3               ;COLINC = $7A           ;##old##
000000r 3               SWPFLG  = $7B           ;NON-0 1F TXT AND REGULAR RAM IS SWAPPED
000000r 3               HOLDCH  = $7C           ;CH IS MOVED HERE IN KGETCH BEFORE CNTL & SH
000000r 3               INSDAT  = $7D           ;1-byte temporary
000000r 3               COUNTR  = $7E           ;2-byte draw iteration count
000000r 3               
000000r 3               ; Floating Point Package Page Zero Address Equates
000000r 3               
000000r 3               FR0     = $D4           ;6-byte register 0
000000r 3               FR0M    = $D5           ;##rev2## 5-byte register 0 mantissa
000000r 3               QTEMP   = $D9           ;##rev2## 1-byte temporary
000000r 3               
000000r 3               FRE     = $DA           ;6-byte (internal) register E
000000r 3               
000000r 3               FR1     = $E0           ;FP REG1
000000r 3               FR1M    = $E1           ;##rev2## 5-byte register 1 mantissa
000000r 3               
000000r 3               FR2     = $E6           ;6-byte (internal) register 2
000000r 3               
000000r 3               FRX     = $EC           ;1-byte temporary
000000r 3               
000000r 3               EEXP    = $ED           ;VALUE OF E
000000r 3               
000000r 3               FRSIGN  = $EE           ;##rev2## 1-byte floating point sign
000000r 3               NSIGN   = $EE           ;SIGN OF #
000000r 3               
000000r 3               PLYCNT  = $EF           ;##rev2## 1-byte polynomial degree
000000r 3               ESIGN   = $EF           ;SIGN OF EXPONENT
000000r 3               
000000r 3               SGNFLG  = $F0           ;##rev2## 1-byte sign flag
000000r 3               FCHRFLG = $F0           ;1ST CHAR FLAG
000000r 3               
000000r 3               XFMFLG  = $F1           ;##rev2## 1-byte transform flag
000000r 3               DIGRT   = $F1           ;# OF DIGITS RIGHT OF DECIMAL
000000r 3               
000000r 3               CIX     = $F2           ;CURRENT INPUT INDEX
000000r 3               INBUFF  = $F3           ;POINTS TO USER'S LINE INPUT BUFFER
000000r 3               
000000r 3               ZTEMP1  = $F5           ;2-byte temporary
000000r 3               ZTEMP4  = $F7           ;2-byte temporary
000000r 3               ZTEMP3  = $F9           ;2-byte temporary
000000r 3               
000000r 3               ;DEGFLG = $FB           ;##old## same as RADFLG
000000r 3               ;RADFLG = $FB           ;##old## 0=RADIANS, 6=DEGREES
000000r 3               
000000r 3               FLPTR   = $FC           ;2-byte floating point number pointer
000000r 3               FPTR2   = $FE           ;2-byte floating point number pointer
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Page Two Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               INTABS  = $0200         ;INTERRUPT RAM
000000r 3               
000000r 3               VDSLST  = $0200         ;DISPLAY LIST NMI VECTOR
000000r 3               VPRCED  = $0202         ;PROCEED LINE IRQ VECTOR
000000r 3               VINTER  = $0204         ;INTERRUPT LINE IRQ VECTOR
000000r 3               VBREAK  = $0206         ;SOFTWARE BREAK (00) INSTRUCTION IRQ VECTOR
000000r 3               VKEYBD  = $0208         ;POKEY KEYBOARD IRQ VECTOR
000000r 3               VSERIN  = $020A         ;POKEY SERIAL INPUT READY IRQ
000000r 3               VSEROR  = $020C         ;POKEY SERIAL OUTPUT READY IRQ
000000r 3               VSEROC  = $020E         ;POKEY SERIAL OUTPUT COMPLETE IRQ
000000r 3               VTIMR1  = $0210         ;POKEY TIMER 1 IRQ
000000r 3               VTIMR2  = $0212         ;POKEY TIMER 2 IRQ
000000r 3               VTIMR4  = $0214         ;POKEY TIMER 4 IRQ
000000r 3               VIMIRQ  = $0216         ;IMMEDIATE IRQ VECTOR
000000r 3               CDTMV1  = $0218         ;COUNT DOWN TIMER 1
000000r 3               CDTMV2  = $021A         ;COUNT DOWN TIMER 2
000000r 3               CDTMV3  = $021C         ;COUNT DOWN TIMER 3
000000r 3               CDTMV4  = $021E         ;COUNT DOWN TIMER 4
000000r 3               CDTMV5  = $0220         ;COUNT DOWN TIMER 5
000000r 3               VVBLKI  = $0222         ;IMMEDIATE VERTICAL BLANK NMI VECTOR
000000r 3               VVBLKD  = $0224         ;DEFERRED VERTICAL BLANK NMI VECTOR
000000r 3               CDTMA1  = $0226         ;COUNT DOWN TIMER 1 JSR ADDRESS
000000r 3               CDTMA2  = $0228         ;COUNT DOWN TIMER 2 JSR ADDRESS
000000r 3               CDTMF3  = $022A         ;COUNT DOWN TIMER 3 FLAG
000000r 3               SRTIMR  = $022B         ;SOFTWARE REPEAT TIMER
000000r 3               CDTMF4  = $022C         ;COUNT DOWN TIMER 4 FLAG
000000r 3               INTEMP  = $022D         ;IAN'S TEMP
000000r 3               CDTMF5  = $022E         ;COUNT DOWN TIMER FLAG 5
000000r 3               SDMCTL  = $022F         ;SAVE DMACTL REGISTER
000000r 3               SDLSTL  = $0230         ;SAVE DISPLAY LIST LOW BYTE
000000r 3               SDLSTH  = $0231         ;SAVE DISPLAY LIST HI BYTE
000000r 3               SSKCTL  = $0232         ;SKCTL REGISTER RAM
000000r 3               LCOUNT  = $0233         ;##1200xl## 1-byte relocating loader record
000000r 3               LPENH   = $0234         ;LIGHT PEN HORIZONTAL VALUE
000000r 3               LPENV   = $0235         ;LIGHT PEN VERTICAL VALUE
000000r 3               BRKKY   = $0236         ;BREAK KEY VECTOR
000000r 3               ;RELADR = $0238         ;##1200xl## 2-byte relocatable loader address
000000r 3               VPIRQ   = $0238         ;##rev2## 2-byte parallel device IRQ vector
000000r 3               CDEVIC  = $023A         ;COMMAND FRAME BUFFER - DEVICE
000000r 3               CCOMND  = $023B         ;COMMAND
000000r 3               CAUX1   = $023C         ;COMMAND AUX BYTE 1
000000r 3               CAUX2   = $023D         ;COMMAND AUX BYTE 2
000000r 3               
000000r 3               TEMP    = $023E         ;TEMPORARY RAM CELL
000000r 3               
000000r 3               ERRFLG  = $023F         ;ERROR FLAG - ANY DEVICE ERROR EXCEPT TIME OUT
000000r 3               
000000r 3               DFLAGS  = $0240         ;DISK FLAGS FROM SECTOR ONE
000000r 3               DBSECT  = $0241         ;NUMBER OF DISK BOOT SECTORS
000000r 3               BOOTAD  = $0242         ;ADDRESS WHERE DISK BOOT LOADER WILL BE PUT
000000r 3               COLDST  = $0244         ;COLDSTART FLAG (1=IN MIDDLE OF COLDSTART>
000000r 3               RECLEN  = $0245         ;##1200xl## 1-byte relocating loader record length
000000r 3               DSKTIM  = $0246         ;DISK TIME OUT REGISTER
000000r 3               ;LINBUF = $0247         ;##old## CHAR LINE BUFFER
000000r 3               PDVMSK  = $0247         ;##rev2## 1-byte parallel device selection mask
000000r 3               SHPDVS  = $0248         ;##rev2## 1-byte PDVS (parallel device select)
000000r 3               PDIMSK  = $0249         ;##rev2## 1-byte parallel device IRQ selection
000000r 3               RELADR  = $024A         ;##rev2## 2-byte relocating loader relative adr.
000000r 3               PPTMPA  = $024C         ;##rev2## 1-byte parallel device handler temporary
000000r 3               PPTMPX  = $024D         ;##rev2## 1-byte parallel device handler temporary
000000r 3               
000000r 3               CHSALT  = $026B         ;##1200xl## 1-byte character set alternate
000000r 3               VSFLAG  = $026C         ;##1200xl## 1-byte fine vertical scroll count
000000r 3               KEYDIS  = $026D         ;##1200xl## 1-byte keyboard disable
000000r 3               FINE    = $026E         ;##1200xl## 1-byte fine scrolling mode
000000r 3               GPRIOR  = $026F         ;GLOBAL PRIORITY CELL
000000r 3               
000000r 3               PADDL0  = $0270         ;1-byte potentiometer 0
000000r 3               PADDL1  = $0271         ;1-byte potentiometer 1
000000r 3               PADDL2  = $0272         ;1-byte potentiometer 2
000000r 3               PADDL3  = $0273         ;1-byte potentiometer 3
000000r 3               PADDL4  = $0274         ;1-byte potentiometer 4
000000r 3               PADDL5  = $0275         ;1-byte potentiometer 5
000000r 3               PADDL6  = $0276         ;1-byte potentiometer 6
000000r 3               PADDL7  = $0277         ;1-byte potentiometer 7
000000r 3               
000000r 3               STICK0  = $0278         ;1-byte joystick 0
000000r 3               STICK1  = $0279         ;1-byte joystick 1
000000r 3               STICK2  = $027A         ;1-byte joystick 2
000000r 3               STICK3  = $027B         ;1-byte joystick 3
000000r 3               
000000r 3               PTRIG0  = $027C         ;1-byte paddle trigger 0
000000r 3               PTRIG1  = $027D         ;1-byte paddle trigger 1
000000r 3               PTRIG2  = $027E         ;1-byte paddle trigger 2
000000r 3               PTRIG3  = $027F         ;1-byte paddle trigger 3
000000r 3               PTRIG4  = $0280         ;1-byte paddle trigger 4
000000r 3               PTRIG5  = $0281         ;1-byte paddle trigger 5
000000r 3               PTRIG6  = $0281         ;1-byte paddle trigger 6
000000r 3               PTRIG7  = $0283         ;1-byte paddle trigger 7
000000r 3               
000000r 3               STRIG0  = $0284         ;1-byte joystick trigger 0
000000r 3               STRIG1  = $0285         ;1-byte joystick trigger 1
000000r 3               STRIG2  = $0286         ;1-byte joystick trigger 2
000000r 3               STRIG3  = $0287         ;1-byte joystick trigger 3
000000r 3               
000000r 3               ;CSTAT  = $0288         ;##old## cassette status register
000000r 3               HIBYTE  = $0288         ;##1200xl## 1-byte relocating loader high byte
000000r 3               WMODE   = $0289         ;1-byte cassette WRITE mode
000000r 3               BLIM    = $028A         ;1-byte cassette buffer limit
000000r 3               IMASK   = $028B         ;##rev2## (not used)
000000r 3               JVECK   = $028C         ;2-byte jump vector or temporary
000000r 3               NEWADR  = $028E         ;##1200xl## 2-byte relocating address
000000r 3               TXTROW  = $0290         ;TEXT ROWCRS
000000r 3               TXTCOL  = $0291         ;TEXT COLCRS
000000r 3               TINDEX  = $0293         ;TEXT INDEX
000000r 3               TXTMSC  = $0294         ;FOOLS CONVRT INTO NEW MSC
000000r 3               TXTOLD  = $0296         ;OLDROW & OLDCOL FOR TEXT (AND THEN SOME)
000000r 3               ;TMPX1  = $029C         ;##old## 1-byte temporary register
000000r 3               CRETRY  = $029C         ;##1200xl## 1-byte number of command frame retries
000000r 3               HOLD3   = $029D         ;1-byte temporary
000000r 3               SUBTMP  = $029E         ;1-byte temporary
000000r 3               HOLD2   = $029F         ;1-byte (not used)
000000r 3               DMASK   = $02A0         ;1-byte display (pixel location) mask
000000r 3               TMPLBT  = $02A1         ;1-byte (not used)
000000r 3               ESCFLG  = $02A2         ;ESCAPE FLAG
000000r 3               TABMAP  = $02A3         ;15-byte (120 bit) tab stop bit map
000000r 3               LOGMAP  = $02B2         ;LOGICAL LINE START BIT MAP
000000r 3               INVFLG  = $02B6         ;INVERSE VIDEO FLAG (TOGGLED BY ATARI KEY)
000000r 3               FILFLG  = $02B7         ;RIGHT FILL FLAG FOR DRAW
000000r 3               TMPROW  = $02B8         ;1-byte temporary row
000000r 3               TMPCOL  = $02B9         ;2-byte temporary column
000000r 3               SCRFLG  = $02BB         ;SET IF SCROLL OCCURS
000000r 3               HOLD4   = $02BC         ;TEMP CELL USED IN DRAW ONLY
000000r 3               ;HOLD5  = $02BD         ;##old## DITTO
000000r 3               DRETRY  = $02BD         ;##1200xl## 1-byte number of device retries
000000r 3               SHFLOK  = $02BE         ;1-byte shift/control lock flags
000000r 3               BOTSCR  = $02BF         ;BOTTOM OF SCREEN   24 NORM 4 SPLIT
000000r 3               
000000r 3               PCOLR0  = $02C0         ;1-byte player-missile 0 color/luminance
000000r 3               PCOLR1  = $02C1         ;1-byte player-missile 1 color/luminance
000000r 3               PCOLR2  = $02C2         ;1-byte player-missile 2 color/luminance
000000r 3               PCOLR3  = $02C3         ;1-byte player-missile 3 color/luminance
000000r 3               
000000r 3               COLOR0  = $02C4         ;1-byte playfield 0 color/luminance
000000r 3               COLOR1  = $02C5         ;1-byte playfield 1 color/luminance
000000r 3               COLOR2  = $02C6         ;1-byte playfield 2 color/luminance
000000r 3               COLOR3  = $02C7         ;1-byte playfield 3 color/luminance
000000r 3               
000000r 3               COLOR4  = $02C8         ;1-byte background color/luminance
000000r 3               
000000r 3               PARMBL  = $02C9         ;##rev2## 6-byte relocating loader parameter
000000r 3               RUNADR  = $02C9         ;##1200xl## 2-byte run address
000000r 3               HIUSED  = $02CB         ;##1200xl## 2-byte highest non-zero page address
000000r 3               ZHIUSE  = $02CD         ;##1200xl## 2-byte highest zero page address
000000r 3               
000000r 3               OLDPAR  = $02CF         ;##rev2## 6-byte relocating loader parameter
000000r 3               GBYTEA  = $02CF         ;##1200xl## 2-byte GET-BYTE routine address
000000r 3               LOADAD  = $02D1         ;##1200xl## 2-byte non-zero page load address
000000r 3               ZLOADA  = $02D3         ;##1200xl## 2-byte zero page load address
000000r 3               
000000r 3               DSCTLN  = $02D5         ;##1200xl## 2-byte disk sector length
000000r 3               ACMISR  = $02D7         ;##1200xl## 2-byte ACMI interrupt service routine
000000r 3               KRPDEL  = $02D9         ;##1200xl## 1-byte auto-repeat delay
000000r 3               KEYREP  = $02DA         ;##1200xl## 1-byte auto-repeat rate
000000r 3               NOCLIK  = $02DB         ;##1200xl## 1-byte key click disable
000000r 3               HELPFG  = $02DC         ;##1200xl## 1-byte HELP key flag (0 = no HELP)
000000r 3               DMASAV  = $02DD         ;##1200xl## 1-byte SDMCTL save/restore
000000r 3               PBPNT   = $02DE         ;##1200xl## 1-byte printer buffer pointer
000000r 3               PBUFSZ  = $02DF         ;##1200xl## 1-byte printer buffer size
000000r 3               
000000r 3               GLBABS  = $02E0         ;4-byte global variables for non-DOS users
000000r 3               RUNAD   = $02E0         ;##map## 2-byte binary file run address
000000r 3               INITAD  = $02E2         ;##map## 2-byte binary file initialization address
000000r 3               
000000r 3               RAMSIZ  = $02E4         ;RAM SIZE (HI BYTE ONLY)
000000r 3               MEMTOP  = $02E5         ;TOP OF AVAILABLE USER MEMORY
000000r 3               MEMLO   = $02E7         ;BOTTOM OF AVAILABLE USER MEMORY
000000r 3               HNDLOD  = $02E9         ;##1200xl## 1-byte user load flag
000000r 3               DVSTAT  = $02EA         ;STATUS BUFFER
000000r 3               CBAUDL  = $02EE         ;1-byte low cassette baud rate
000000r 3               CBAUDH  = $02EF         ;1-byte high cassette baud rate
000000r 3               CRSINH  = $02F0         ;CURSOR INHIBIT (00 = CURSOR ON)
000000r 3               KEYDEL  = $02F1         ;KEY DELAY
000000r 3               CH1     = $02F2         ;1-byte prior keyboard character
000000r 3               CHACT   = $02F3         ;CHACTL REGISTER RAM
000000r 3               CHBAS   = $02F4         ;CHBAS REGISTER RAM
000000r 3               
000000r 3               NEWROW  = $02F5         ;##1200xl## 1-byte draw destination row
000000r 3               NEWCOL  = $02F6         ;##1200xl## 2-byte draw destination column
000000r 3               ROWINC  = $02F8         ;##1200xl## 1-byte draw row increment
000000r 3               COLINC  = $02F9         ;##1200xl## 1-byte draw column increment
000000r 3               
000000r 3               CHAR    = $02FA         ;1-byte internal character
000000r 3               ATACHR  = $02FB         ;ATASCII CHARACTER
000000r 3               CH      = $02FC         ;GLOBAL VARIABLE FOR KEYBOARD
000000r 3               FILDAT  = $02FD         ;RIGHT FILL DATA <DRAW>
000000r 3               DSPFLG  = $02FE         ;DISPLAY FLAG   DISPLAY CNTLS IF NON-ZERO
000000r 3               SSFLAG  = $02FF         ;START/STOP FLAG FOR PAGING (CNTL 1). CLEARE
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Page Three Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               DCB     = $0300         ;DEVICE CONTROL BLOCK
000000r 3               DDEVIC  = $0300         ;PERIPHERAL UNIT 1 BUS I.D. NUMBER
000000r 3               DUNIT   = $0301         ;UNIT NUMBER
000000r 3               DCOMND  = $0302         ;BUS COMMAND
000000r 3               DSTATS  = $0303         ;COMMAND TYPE/STATUS RETURN
000000r 3               DBUFLO  = $0304         ;1-byte low data buffer address
000000r 3               DBUFHI  = $0305         ;1-byte high data buffer address
000000r 3               DTIMLO  = $0306         ;DEVICE TIME OUT IN 1 SECOND UNITS
000000r 3               DUNUSE  = $0307         ;UNUSED BYTE
000000r 3               DBYTLO  = $0308         ;1-byte low number of bytes to transfer
000000r 3               DBYTHI  = $0309         ;1-byte high number of bytes to transfer
000000r 3               DAUX1   = $030A         ;1-byte first command auxiliary
000000r 3               DAUX2   = $030B         ;1-byte second command auxiliary
000000r 3               
000000r 3               TIMER1  = $030C         ;INITIAL TIMER VALUE
000000r 3               ;ADDCOR = $030E         ;##old## ADDITION CORRECTION
000000r 3               JMPERS  = $030E         ;##1200xl## 1-byte jumper options
000000r 3               CASFLG  = $030F         ;CASSETTE MODE WHEN SET
000000r 3               TIMER2  = $0310         ;2-byte final baud rate timer value
000000r 3               TEMP1   = $0312         ;TEMPORARY STORAGE REGISTER
000000r 3               ;TEMP2  = $0314         ;##old## TEMPORARY STORAGE REGISTER
000000r 3               TEMP2   = $0313         ;##1200xl## 1-byte temporary
000000r 3               PTIMOT  = $0314         ;##1200xl## 1-byte printer timeout
000000r 3               TEMP3   = $0315         ;TEMPORARY STORAGE REGISTER
000000r 3               SAVIO   = $0316         ;SAVE SERIAL IN DATA PORT
000000r 3               TIMFLG  = $0317         ;TIME OUT FLAG FOR BAUD RATE CORRECTION
000000r 3               STACKP  = $0318         ;SIO STACK POINTER SAVE CELL
000000r 3               TSTAT   = $0319         ;TEMPORARY STATUS HOLDER
000000r 3               
000000r 3               HATABS  = $031A         ;35-byte handler address table (was 38 bytes)
000000r 3               PUPBT1  = $033D         ;##1200xl## 1-byte power-up validation byte 1
000000r 3               PUPBT2  = $033E         ;##1200xl## 1-byte power-up validation byte 2
000000r 3               PUPBT3  = $033F         ;##1200xl## 1-byte power-up validation byte 3
000000r 3               
000000r 3               IOCB    = $0340         ;I/O CONTROL BLOCKS
000000r 3               ICHID   = $0340         ;HANDLER INDEX NUMBER (FF=IOCB FREE)
000000r 3               ICDNO   = $0341         ;DEVICE NUMBER (DRIVE NUMBER)
000000r 3               ICCOM   = $0342         ;COMMAND CODE
000000r 3               ICSTA   = $0343         ;STATUS OF LAST IOCB ACTION
000000r 3               ICBAL   = $0344         ;1-byte low buffer address
000000r 3               ICBAH   = $0345         ;1-byte high buffer address
000000r 3               ICPTL   = $0346         ;1-byte low PUT-BYTE routine address - 1
000000r 3               ICPTH   = $0347         ;1-byte high PUT-BYTE routine address - 1
000000r 3               ICBLL   = $0348         ;1-byte low buffer length
000000r 3               ICBLH   = $0349         ;1-byte high buffer length
000000r 3               ICAX1   = $034A         ;1-byte first auxiliary information
000000r 3               ICAX2   = $034B         ;1-byte second auxiliary information
000000r 3               ICAX3   = $034C         ;1-byte third auxiliary information
000000r 3               ICAX4   = $034D         ;1-byte fourth auxiliary information
000000r 3               ICAX5   = $034E         ;1-byte fifth auxiliary information
000000r 3               ICSPR   = $034F         ;SPARE BYTE
000000r 3               
000000r 3               PRNBUF  = $03C0         ;PRINTER BUFFER
000000r 3               SUPERF  = $03E8         ;##1200xl## 1-byte editor super function flag
000000r 3               CKEY    = $03E9         ;##1200xl## 1-byte cassette boot request flag
000000r 3               CASSBT  = $03EA         ;##1200xl## 1-byte cassette boot flag
000000r 3               CARTCK  = $03EB         ;##1200xl## 1-byte cartridge equivalence check
000000r 3               DERRF   = $03EC         ;##rev2## 1-byte screen OPEN error flag
000000r 3               
000000r 3               ; Remainder of Page Three Not Cleared upon Reset
000000r 3               
000000r 3               ACMVAR  = $03ED         ;##1200xl## 11 bytes reserved for ACMI
000000r 3               BASICF  = $03F8         ;##rev2## 1-byte BASIC switch flag
000000r 3               MINTLK  = $03F9         ;##1200xl## 1-byte ACMI module interlock
000000r 3               GINTLK  = $03FA         ;##1200xl## 1-byte cartridge interlock
000000r 3               CHLINK  = $03FB         ;##1200xl## 2-byte loaded handler chain link
000000r 3               CASBUF  = $03FD         ;CASSETTE BUFFER
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Page Four/Five Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               ; USER AREA STARTS HERE AND GOES TO END OF PAGE FIVE
000000r 3               USAREA  = $0480         ;128 bytes reserved for application
000000r 3               
000000r 3               LBPR1   = $057E         ;LBUFF PREFIX 1
000000r 3               LBPR2   = $057F         ;LBUFF PREFIX 2
000000r 3               LBUFF   = $0580         ;128-byte line buffer
000000r 3               
000000r 3               PLYARG  = $05E0         ;6-byte floating point polynomial argument
000000r 3               FPSCR   = $05E6         ;6-byte floating point temporary
000000r 3               FPSCR1  = $05EC         ;6-byte floating point temporary
000000r 3               
000000r 3               ;LBFEND = $05FF         ;##old## END OF LBUFF
000000r 3               
000000r 3               
000000r 3               DOS     = $0700
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; SpartaDOS-X Definitions
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               SDX_FLAG     = DOS              ; 'S' for SpartaDOS
000000r 3               SDX_VERSION  = $0701            ; SD version (e.g. $32 = 3.2, $40 = 4.0)
000000r 3                                               ; address $0702 contains sub-version, e.g.
000000r 3                                               ; 8 in case of SDX 4.48
000000r 3               SDX_KERNEL   = $0703            ; SDX kernel entry point
000000r 3               SDX_BLOCK_IO = $0706            ; block I/O entry point
000000r 3               SDX_MISC     = $0709            ; "misc" entry point
000000r 3               SDX_DEVICE   = $0761
000000r 3               SDX_DATE     = $077B            ; day, month, year (3 bytes)
000000r 3               SDX_TIME     = $077E            ; hour, min, sec (3 bytes)
000000r 3               SDX_DATESET  = $0781
000000r 3               SDX_PATH     = $07A0            ; 64 bytes
000000r 3               SDX_IFSYMBOL = $07EB            ; only valid on SDX 4.40 or newer
000000r 3               SDX_S_LOOKUP = SDX_IFSYMBOL     ; alternative name for SDX_IFSYMBOL
000000r 3               
000000r 3               ; values for SDX_DEVICE
000000r 3               
000000r 3               SDX_CLK_DEV  = $10              ; clock device
000000r 3               
000000r 3               ; clock device functions
000000r 3               
000000r 3               SDX_KD_GETTD = 100              ; get time and date
000000r 3               SDX_KD_SETTD = 101              ; set time and date
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Cartridge Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               CARTCS  = $BFFA         ;##rev2## 2-byte cartridge coldstart address
000000r 3               CART    = $BFFC         ;##rev2## 1-byte cartridge present indicator
000000r 3                                       ;0=Cart Exists
000000r 3               CARTFG  = $BFFD         ;##rev2## 1-byte cartridge flags
000000r 3                                       ;D7  0=Not a Diagnostic Cart
000000r 3                                       ;    1=Is a Diagnostic cart and control is
000000r 3                                       ;      given to cart before any OS is init.
000000r 3                                       ;D2  0=Init but Do not Start Cart
000000r 3                                       ;    1=Init and Start Cart
000000r 3                                       ;D0  0=Do not boot disk
000000r 3                                       ;    1=Boot Disk
000000r 3               CARTAD  = $BFFE         ;##rev2## 2-byte cartridge start vector
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; CTIA/GTIA Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               GTIA    = $D000         ;CTIA/GTIA area
000000r 3               .include "atari_gtia.inc"
000000r 4               ;-------------------------------------------------------------------------
000000r 4               ; CTIA/GTIA Address Equates
000000r 4               ;-------------------------------------------------------------------------
000000r 4               
000000r 4               ; Read/Write Addresses
000000r 4               
000000r 4               CONSOL  = GTIA + $1F         ;console switches and speaker control
000000r 4               
000000r 4               ; Read Addresses
000000r 4               
000000r 4               M0PF    = GTIA + $00         ;missile 0 and playfield collision
000000r 4               M1PF    = GTIA + $01         ;missile 1 and playfield collision
000000r 4               M2PF    = GTIA + $02         ;missile 2 and playfield collision
000000r 4               M3PF    = GTIA + $03         ;missile 3 and playfield collision
000000r 4               
000000r 4               P0PF    = GTIA + $04         ;player 0 and playfield collision
000000r 4               P1PF    = GTIA + $05         ;player 1 and playfield collision
000000r 4               P2PF    = GTIA + $06         ;player 2 and playfield collision
000000r 4               P3PF    = GTIA + $07         ;player 3 and playfield collision
000000r 4               
000000r 4               M0PL    = GTIA + $08         ;missile 0 and player collision
000000r 4               M1PL    = GTIA + $09         ;missile 1 and player collision
000000r 4               M2PL    = GTIA + $0A         ;missile 2 and player collision
000000r 4               M3PL    = GTIA + $0B         ;missile 3 and player collision
000000r 4               
000000r 4               P0PL    = GTIA + $0C         ;player 0 and player collision
000000r 4               P1PL    = GTIA + $0D         ;player 1 and player collision
000000r 4               P2PL    = GTIA + $0E         ;player 2 and player collision
000000r 4               P3PL    = GTIA + $0F         ;player 3 and player collision
000000r 4               
000000r 4               TRIG0   = GTIA + $10         ;joystick trigger 0
000000r 4               TRIG1   = GTIA + $11         ;joystick trigger 1
000000r 4               
000000r 4               TRIG2   = GTIA + $12         ;cartridge interlock
000000r 4               TRIG3   = GTIA + $13         ;ACMI module interlock
000000r 4               
000000r 4               PAL     = GTIA + $14         ;##rev2## PAL/NTSC indicator
000000r 4               
000000r 4               ; Write Addresses
000000r 4               
000000r 4               HPOSP0  = GTIA + $00         ;player 0 horizontal position
000000r 4               HPOSP1  = GTIA + $01         ;player 1 horizontal position
000000r 4               HPOSP2  = GTIA + $02         ;player 2 horizontal position
000000r 4               HPOSP3  = GTIA + $03         ;player 3 horizontal position
000000r 4               
000000r 4               HPOSM0  = GTIA + $04         ;missile 0 horizontal position
000000r 4               HPOSM1  = GTIA + $05         ;missile 1 horizontal position
000000r 4               HPOSM2  = GTIA + $06         ;missile 2 horizontal position
000000r 4               HPOSM3  = GTIA + $07         ;missile 3 horizontal position
000000r 4               
000000r 4               SIZEP0  = GTIA + $08         ;player 0 size
000000r 4               SIZEP1  = GTIA + $09         ;player 1 size
000000r 4               SIZEP2  = GTIA + $0A         ;player 2 size
000000r 4               SIZEP3  = GTIA + $0B         ;player 3 size
000000r 4               
000000r 4               SIZEM   = GTIA + $0C         ;missile sizes
000000r 4               
000000r 4               GRAFP0  = GTIA + $0D         ;player 0 graphics
000000r 4               GRAFP1  = GTIA + $0E         ;player 1 graphics
000000r 4               GRAFP2  = GTIA + $0F         ;player 2 graphics
000000r 4               GRAFP3  = GTIA + $10         ;player 3 graphics
000000r 4               
000000r 4               GRAFM   = GTIA + $11         ;missile graphics
000000r 4               
000000r 4               COLPM0  = GTIA + $12         ;player-missile 0 color/luminance
000000r 4               COLPM1  = GTIA + $13         ;player-missile 1 color/luminance
000000r 4               COLPM2  = GTIA + $14         ;player-missile 2 color/luminance
000000r 4               COLPM3  = GTIA + $15         ;player-missile 3 color/luminance
000000r 4               
000000r 4               COLPF0  = GTIA + $16         ;playfield 0 color/luminance
000000r 4               COLPF1  = GTIA + $17         ;playfield 1 color/luminance
000000r 4               COLPF2  = GTIA + $18         ;playfield 2 color/luminance
000000r 4               COLPF3  = GTIA + $19         ;playfield 3 color/luminance
000000r 4               
000000r 4               COLBK   = GTIA + $1A         ;background color/luminance
000000r 4               
000000r 4               PRIOR   = GTIA + $1B         ;priority select
000000r 4               VDELAY  = GTIA + $1C         ;vertical delay
000000r 4               GRACTL  = GTIA + $1D         ;graphic control
000000r 4               HITCLR  = GTIA + $1E         ;collision clear
000000r 4               
000000r 4               
000000r 4               ; Hue values
000000r 4               
000000r 4               HUE_GREY        = 0
000000r 4               HUE_GOLD        = 1
000000r 4               HUE_GOLDORANGE  = 2
000000r 4               HUE_REDORANGE   = 3
000000r 4               HUE_ORANGE      = 4
000000r 4               HUE_MAGENTA     = 5
000000r 4               HUE_PURPLE      = 6
000000r 4               HUE_BLUE        = 7
000000r 4               HUE_BLUE2       = 8
000000r 4               HUE_CYAN        = 9
000000r 4               HUE_BLUEGREEN   = 10
000000r 4               HUE_BLUEGREEN2  = 11
000000r 4               HUE_GREEN       = 12
000000r 4               HUE_YELLOWGREEN = 13
000000r 4               HUE_YELLOW      = 14
000000r 4               HUE_YELLOWRED   = 15
000000r 4               
000000r 4               ; Color defines, similar to c64 colors (untested)
000000r 4               
000000r 4               GTIA_COLOR_BLACK      = (HUE_GREY << 4)
000000r 4               GTIA_COLOR_WHITE      = (HUE_GREY << 4 | 7 << 1)
000000r 4               GTIA_COLOR_RED        = (HUE_REDORANGE << 4 | 1 << 1)
000000r 4               GTIA_COLOR_CYAN       = (HUE_CYAN << 4 | 3 << 1)
000000r 4               GTIA_COLOR_VIOLET     = (HUE_PURPLE << 4 | 4 << 1)
000000r 4               GTIA_COLOR_GREEN      = (HUE_GREEN << 4 | 2 << 1)
000000r 4               GTIA_COLOR_BLUE       = (HUE_BLUE << 4 | 2 << 1)
000000r 4               GTIA_COLOR_YELLOW     = (HUE_YELLOW << 4 | 7 << 1)
000000r 4               GTIA_COLOR_ORANGE     = (HUE_ORANGE << 4 | 5 << 1)
000000r 4               GTIA_COLOR_BROWN      = (HUE_YELLOW << 4 | 2 << 1)
000000r 4               GTIA_COLOR_LIGHTRED   = (HUE_REDORANGE << 4 | 6 << 1)
000000r 4               GTIA_COLOR_GRAY1      = (HUE_GREY << 4 | 2 << 1)
000000r 4               GTIA_COLOR_GRAY2      = (HUE_GREY << 4 | 3 << 1)
000000r 4               GTIA_COLOR_LIGHTGREEN = (HUE_GREEN << 4 | 6 << 1)
000000r 4               GTIA_COLOR_LIGHTBLUE  = (HUE_BLUE << 4 | 6 << 1)
000000r 4               GTIA_COLOR_GRAY3      = (HUE_GREY << 4 | 5 << 1)
000000r 4               
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; PBI Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               PBI     = $D100         ;##rev2## parallel bus interface area
000000r 3               
000000r 3               ; Read Addresses
000000r 3               
000000r 3               PDVI    = $D1FF         ;##rev2## parallel device IRQ status
000000r 3               
000000r 3               ; Write Addresses
000000r 3               
000000r 3               PDVS    = $D1FF         ;##rev2## parallel device select
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; POKEY Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               POKEY     = $D200         ;POKEY area
000000r 3               .include  "atari_pokey.inc"
000000r 4               ;-------------------------------------------------------------------------
000000r 4               ; POKEY Address Equates
000000r 4               ;-------------------------------------------------------------------------
000000r 4               
000000r 4               ; Read Addresses
000000r 4               
000000r 4               POT0    = POKEY + $00         ;potentiometer 0
000000r 4               POT1    = POKEY + $01         ;potentiometer 1
000000r 4               POT2    = POKEY + $02         ;potentiometer 2
000000r 4               POT3    = POKEY + $03         ;potentiometer 3
000000r 4               POT4    = POKEY + $04         ;potentiometer 4
000000r 4               POT5    = POKEY + $05         ;potentiometer 5
000000r 4               POT6    = POKEY + $06         ;potentiometer 6
000000r 4               POT7    = POKEY + $07         ;potentiometer 7
000000r 4               
000000r 4               ALLPOT  = POKEY + $08         ;potentiometer port status
000000r 4               KBCODE  = POKEY + $09         ;keyboard code
000000r 4               RANDOM  = POKEY + $0A         ;random number generator
000000r 4               SERIN   = POKEY + $0D         ;serial port input
000000r 4               IRQST   = POKEY + $0E         ;IRQ interrupt status
000000r 4               SKSTAT  = POKEY + $0F         ;serial port and keyboard status
000000r 4               
000000r 4               ; Write Addresses
000000r 4               
000000r 4               AUDF1   = POKEY + $00         ;channel 1 audio frequency
000000r 4               AUDC1   = POKEY + $01         ;channel 1 audio control
000000r 4               
000000r 4               AUDF2   = POKEY + $02         ;channel 2 audio frequency
000000r 4               AUDC2   = POKEY + $03         ;channel 2 audio control
000000r 4               
000000r 4               AUDF3   = POKEY + $04         ;channel 3 audio frequency
000000r 4               AUDC3   = POKEY + $05         ;channel 3 audio control
000000r 4               
000000r 4               AUDF4   = POKEY + $06         ;channel 4 audio frequency
000000r 4               AUDC4   = POKEY + $07         ;channel 4 audio control
000000r 4               
000000r 4               AUDCTL  = POKEY + $08         ;audio control
000000r 4               STIMER  = POKEY + $09         ;start timers
000000r 4               SKRES   = POKEY + $0A         ;reset SKSTAT status
000000r 4               POTGO   = POKEY + $0B         ;start potentiometer scan sequence
000000r 4               SEROUT  = POKEY + $0D         ;serial port output
000000r 4               IRQEN   = POKEY + $0E         ;IRQ interrupt enable
000000r 4               SKCTL   = POKEY + $0F         ;serial port and keyboard control
000000r 4               
000000r 3               
000000r 3               ; POKEY KBCODE Values
000000r 3               
000000r 3               KEY_NONE    = $FF
000000r 3               
000000r 3               KEY_0       = $32
000000r 3               KEY_1       = $1F
000000r 3               KEY_2       = $1E
000000r 3               KEY_3       = $1A
000000r 3               KEY_4       = $18
000000r 3               KEY_5       = $1D
000000r 3               KEY_6       = $1B
000000r 3               KEY_7       = $33
000000r 3               KEY_8       = $35
000000r 3               KEY_9       = $30
000000r 3               
000000r 3               KEY_A       = $3F
000000r 3               KEY_B       = $15
000000r 3               KEY_C       = $12
000000r 3               KEY_D       = $3A
000000r 3               KEY_E       = $2A
000000r 3               KEY_F       = $38
000000r 3               KEY_G       = $3D
000000r 3               KEY_H       = $39
000000r 3               KEY_I       = $0D
000000r 3               KEY_J       = $01
000000r 3               KEY_K       = $05
000000r 3               KEY_L       = $00
000000r 3               KEY_M       = $25
000000r 3               KEY_N       = $23
000000r 3               KEY_O       = $08
000000r 3               KEY_P       = $0A
000000r 3               KEY_Q       = $2F
000000r 3               KEY_R       = $28
000000r 3               KEY_S       = $3E
000000r 3               KEY_T       = $2D
000000r 3               KEY_U       = $0B
000000r 3               KEY_V       = $10
000000r 3               KEY_W       = $2E
000000r 3               KEY_X       = $16
000000r 3               KEY_Y       = $2B
000000r 3               KEY_Z       = $17
000000r 3               
000000r 3               KEY_COMMA       = $20
000000r 3               KEY_PERIOD      = $22
000000r 3               KEY_SLASH       = $26
000000r 3               KEY_SEMICOLON   = $02
000000r 3               KEY_PLUS        = $06
000000r 3               KEY_ASTERISK    = $07
000000r 3               KEY_DASH        = $0E
000000r 3               KEY_EQUALS      = $0F
000000r 3               KEY_LESSTHAN    = $36
000000r 3               KEY_GREATERTHAN = $37
000000r 3               
000000r 3               KEY_ESC     = $1C
000000r 3               KEY_TAB     = $2C
000000r 3               KEY_SPACE   = $21
000000r 3               KEY_RETURN  = $0C
000000r 3               KEY_DELETE  = $34
000000r 3               KEY_CAPS    = $3C
000000r 3               KEY_INVERSE = $27
000000r 3               KEY_HELP    = $11
000000r 3               
000000r 3               KEY_F1      = $03
000000r 3               KEY_F2      = $04
000000r 3               KEY_F3      = $13
000000r 3               KEY_F4      = $14
000000r 3               
000000r 3               KEY_SHIFT   = $40
000000r 3               KEY_CTRL    = $80
000000r 3               
000000r 3               ; Composed keys
000000r 3               
000000r 3               KEY_EXCLAMATIONMARK = KEY_1 | KEY_SHIFT
000000r 3               KEY_QUOTE           = KEY_2 | KEY_SHIFT
000000r 3               KEY_HASH            = KEY_3 | KEY_SHIFT
000000r 3               KEY_DOLLAR          = KEY_4 | KEY_SHIFT
000000r 3               KEY_PERCENT         = KEY_5 | KEY_SHIFT
000000r 3               KEY_AMPERSAND       = KEY_6 | KEY_SHIFT
000000r 3               KEY_APOSTROPHE      = KEY_7 | KEY_SHIFT
000000r 3               KEY_AT              = KEY_8 | KEY_SHIFT
000000r 3               KEY_OPENINGPARAN    = KEY_9 | KEY_SHIFT
000000r 3               KEY_CLOSINGPARAN    = KEY_0 | KEY_SHIFT
000000r 3               KEY_UNDERLINE       = KEY_DASH | KEY_SHIFT
000000r 3               KEY_BAR             = KEY_EQUALS | KEY_SHIFT
000000r 3               KEY_COLON           = KEY_SEMICOLON | KEY_SHIFT
000000r 3               KEY_BACKSLASH       = KEY_PLUS | KEY_SHIFT
000000r 3               KEY_CIRCUMFLEX      = KEY_ASTERISK | KEY_SHIFT
000000r 3               KEY_OPENINGBRACKET  = KEY_COMMA | KEY_SHIFT
000000r 3               KEY_CLOSINGBRACKET  = KEY_PERIOD | KEY_SHIFT
000000r 3               KEY_QUESTIONMARK    = KEY_SLASH | KEY_SHIFT
000000r 3               KEY_CLEAR           = KEY_LESSTHAN | KEY_SHIFT
000000r 3               KEY_INSERT          = KEY_GREATERTHAN | KEY_SHIFT
000000r 3               
000000r 3               KEY_UP              = KEY_UNDERLINE | KEY_CTRL
000000r 3               KEY_DOWN            = KEY_EQUALS | KEY_CTRL
000000r 3               KEY_LEFT            = KEY_PLUS | KEY_CTRL
000000r 3               KEY_RIGHT           = KEY_ASTERISK | KEY_CTRL
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; ANTIC Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               ANTIC     = $D400         ;ANTIC area
000000r 3               .include  "atari_antic.inc"
000000r 4               ;-------------------------------------------------------------------------
000000r 4               ; ANTIC Address Equates
000000r 4               ;-------------------------------------------------------------------------
000000r 4               
000000r 4               ; Read Addresses
000000r 4               
000000r 4               VCOUNT  = ANTIC + $0B         ;vertical line counter
000000r 4               PENH    = ANTIC + $0C         ;light pen horizontal position
000000r 4               PENV    = ANTIC + $0D         ;light pen vertical position
000000r 4               NMIST   = ANTIC + $0F         ;NMI interrupt status
000000r 4               
000000r 4               ; Write Addresses
000000r 4               
000000r 4               DMACTL  = ANTIC + $00         ;DMA control
000000r 4               CHACTL  = ANTIC + $01         ;character control
000000r 4               DLISTL  = ANTIC + $02         ;low display list address
000000r 4               DLISTH  = ANTIC + $03         ;high display list address
000000r 4               HSCROL  = ANTIC + $04         ;horizontal scroll
000000r 4               VSCROL  = ANTIC + $05         ;vertical scroll
000000r 4               PMBASE  = ANTIC + $07         ;player-missile base address
000000r 4               CHBASE  = ANTIC + $09         ;character base address
000000r 4               WSYNC   = ANTIC + $0A         ;wait for HBLANK synchronization
000000r 4               NMIEN   = ANTIC + $0E         ;NMI enable
000000r 4               NMIRES  = ANTIC + $0F         ;NMI interrupt reset
000000r 4               
000000r 4               
000000r 4               ;-------------------------------------------------------------------------
000000r 4               ; Antic opcodes
000000r 4               ;-------------------------------------------------------------------------
000000r 4               
000000r 4               ; usage example:
000000r 4               ;
000000r 4               ; ScreenDL:
000000r 4               ; .byte DL_BLK8
000000r 4               ; .byte DL_BLK8
000000r 4               ; .byte DL_CHR40x8x1 | DL_LMS | DL_DLI
000000r 4               ; .word ScreenAlignment
000000r 4               ; .byte DL_BLK1 | DL_DLI
000000r 4               ; .byte DL_MAP320x1x1 | DL_LMS
000000r 4               ; .word Screen
000000r 4               ;
000000r 4               ; .repeat 99
000000r 4               ; .byte DL_MAP320x1x1
000000r 4               ; .endrepeat
000000r 4               ; .byte DL_MAP320x1x1 | DL_LMS
000000r 4               ; .word Screen + 40 * 100       ; 100 lines a 40 byte, 'Screen' has to be aligned correctly!
000000r 4               ; .repeat 92
000000r 4               ; .byte DL_MAP320x1x1
000000r 4               ; .endrepeat
000000r 4               ;
000000r 4               ; .byte DL_JVB
000000r 4               
000000r 4               ; absolute instructions (non mode lines)
000000r 4               
000000r 4               DL_JMP  = 1
000000r 4               DL_JVB  = 65
000000r 4               
000000r 4               ; DL_BLKn display n empty lines (just background)
000000r 4               
000000r 4               DL_BLK1  = 0
000000r 4               DL_BLK2  = 16
000000r 4               DL_BLK3  = 32
000000r 4               DL_BLK4  = 48
000000r 4               DL_BLK5  = 64
000000r 4               DL_BLK6  = 80
000000r 4               DL_BLK7  = 96
000000r 4               DL_BLK8  = 112
000000r 4               
000000r 4               ; absolute instructions (mode lines)
000000r 4               
000000r 4               DL_CHR40x8x1  = 2               ; monochrome, 40 character & 8 scanlines per mode line (GR. 0)
000000r 4               DL_CHR40x10x1 = 3               ; monochrome, 40 character & 10 scanlines per mode line
000000r 4               DL_CHR40x8x4  = 4               ; colour, 40 character & 8 scanlines per mode line (GR. 12)
000000r 4               DL_CHR40x16x4 = 5               ; colour, 40 character & 16 scanlines per mode line (GR. 13)
000000r 4               DL_CHR20x8x2  = 6               ; colour (duochrome per character), 20 character & 8 scanlines per mode line (GR. 1)
000000r 4               DL_CHR20x16x2 = 7               ; colour (duochrome per character), 20 character & 16 scanlines per mode line (GR. 2)
000000r 4               
000000r 4               DL_MAP40x8x4  = 8               ; colour, 40 pixel & 8 scanlines per mode line (GR. 3)
000000r 4               DL_MAP80x4x2  = 9               ; 'duochrome', 80 pixel & 4 scanlines per mode line (GR.4)
000000r 4               DL_MAP80x4x4  = 10              ; colour, 80 pixel & 4 scanlines per mode line (GR.5)
000000r 4               DL_MAP160x2x2 = 11              ; 'duochrome', 160 pixel & 2 scanlines per mode line (GR.6)
000000r 4               DL_MAP160x1x2 = 12              ; 'duochrome', 160 pixel & 1 scanline per mode line (GR.14)
000000r 4               DL_MAP160x2x4 = 13              ; 4 colours, 160 pixel & 2 scanlines per mode line (GR.7)
000000r 4               DL_MAP160x1x4 = 14              ; 4 colours, 160 pixel & 1 scanline per mode line (GR.15)
000000r 4               DL_MAP320x1x1 = 15              ; monochrome, 320 pixel & 1 scanline per mode line (GR.8)
000000r 4               
000000r 4               ; modifiers on mode lines...
000000r 4               
000000r 4               DL_HSCROL = 16
000000r 4               DL_VSCROL = 32
000000r 4               DL_LMS    = 64
000000r 4               
000000r 4               ; general modifier...
000000r 4               
000000r 4               DL_DLI    = 128
000000r 4               
000000r 3               
000000r 3               ; PBI RAM Address Equates
000000r 3               
000000r 3               PBIRAM  = $D600         ;##rev2## parallel bus interface RAM area
000000r 3               
000000r 3               ; Parallel Device Address Equates
000000r 3               
000000r 3               PDID1   = $D803         ;##rev2## parallel device ID 1
000000r 3               PDIDV   = $D805         ;##rev2## parallel device I/O vector
000000r 3               PDIRQV  = $D808         ;##rev2## parallel device IRQ vector
000000r 3               PDID2   = $D80B         ;##rev2## parallel device ID 2
000000r 3               PDVV    = $D80D         ;##rev2## parallel device vector table
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; PIA Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               PIA     = $D300         ;PIA area
000000r 3               
000000r 3               PORTA   = $D300         ;port A direction register or jacks one/two
000000r 3               PORTB   = $D301         ;port B direction register or memory management
000000r 3               
000000r 3               PACTL   = $D302         ;port A control
000000r 3               PBCTL   = $D303         ;port B control
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Floating Point Package Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               AFP     = $D800         ;convert ASCII to floating point
000000r 3               FASC    = $D8E6         ;convert floating point to ASCII
000000r 3               IFP     = $D9AA         ;convert integer to floating point
000000r 3               FPI     = $D9D2         ;convert floating point to integer
000000r 3               ZFR0    = $DA44         ;zero FR0
000000r 3               ZF1     = $DA46         ;zero floating point number
000000r 3               FSUB    = $DA60         ;subtract floating point numbers
000000r 3               FADD    = $DA66         ;add floating point numbers
000000r 3               FMUL    = $DADB         ;multiply floating point numbers
000000r 3               FDIV    = $DB28         ;divide floating point numbers
000000r 3               PLYEVL  = $DD40         ;evaluate floating point polynomial
000000r 3               FLD0R   = $DD89         ;load floating point number
000000r 3               FLD0P   = $DD8D         ;load floating point number
000000r 3               FLD1R   = $DD98         ;load floating point number
000000r 3               PLD1P   = $DD9C         ;load floating point number
000000r 3               FST0R   = $DDA7         ;store floating point number
000000r 3               FST0P   = $DDAB         ;store floating point number
000000r 3               FMOVE   = $DDB6         ;move floating point number
000000r 3               LOG     = $DECD         ;calculate floating point logarithm
000000r 3               LOG10   = $DED1         ;calculate floating point base 10 logarithm
000000r 3               EXP     = $DDC0         ;calculate floating point exponential
000000r 3               EXP10   = $DDCC         ;calculate floating point base 10 exponential
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Device Handler Vector Table Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               EDITRV  = $E400         ;editor handler vector table
000000r 3               SCRENV  = $E410         ;screen handler vector table
000000r 3               KEYBDV  = $E420         ;keyboard handler vector table
000000r 3               PRINTV  = $E430         ;printer handler vector table
000000r 3               CASETV  = $E440         ;cassette handler vector table
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Jump Vector Address Equates
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               DISKIV  = $E450         ;vector to initialize DIO
000000r 3               DSKINV  = $E453         ;vector to DIO
000000r 3               .ifdef __ATARIXL__
000000r 3               .ifndef SHRAM_HANDLERS
000000r 3               .import CIO_handler, SIO_handler, SETVBV_handler
000000r 3               .endif
000000r 3               .define CIOV    CIO_handler
000000r 3               .define SIOV    SIO_handler
000000r 3               .define SETVBV  SETVBV_handler
000000r 3               CIOV_org    = $E456     ;vector to CIO
000000r 3               SIOV_org    = $E459     ;vector to SIO
000000r 3               SETVBV_org  = $E45C     ;vector to set VBLANK parameters
000000r 3               .else
000000r 3               CIOV    = $E456         ;vector to CIO
000000r 3               SIOV    = $E459         ;vector to SIO
000000r 3               SETVBV  = $E45C         ;vector to set VBLANK parameters
000000r 3               ; aliases in order not to have to sprinkle common code with .ifdefs
000000r 3               CIOV_org    = CIOV
000000r 3               SIOV_org    = SIOV
000000r 3               SETVBV_org  = SETVBV
000000r 3               .endif
000000r 3               SYSVBV  = $E45F         ;vector to process immediate VBLANK
000000r 3               XITVBV  = $E462         ;vector to process deferred VBLANK
000000r 3               SIOINV  = $E465         ;vector to initialize SIO
000000r 3               SENDEV  = $E468         ;vector to enable SEND
000000r 3               INTINV  = $E46B         ;vector to initialize interrupt handler
000000r 3               CIOINV  = $E46E         ;vector to initialize CIO
000000r 3               BLKBDV  = $E471         ;vector to power-up display
000000r 3               WARMSV  = $E474         ;vector to warmstart
000000r 3               COLDSV  = $E477         ;vector to coldstart
000000r 3               RBLOKV  = $E47A         ;vector to read cassette block
000000r 3               CSOPIV  = $E47D         ;vector to open cassette for input
000000r 3               VCTABL  = $E480         ;RAM vector initial value table
000000r 3               PUPDIV  = $E480         ;##rev2## vector to power-up display
000000r 3               SLFTSV  = $E483         ;##rev2## vector to self-test
000000r 3               PHENTV  = $E486         ;##rev2## vector to enter peripheral handler
000000r 3               PHUNLV  = $E489         ;##rev2## vector to unlink peripheral handler
000000r 3               PHINIV  = $E48C         ;##rev2## vector to initialize peripheral handler
000000r 3               GPDVV   = $E48F         ;##rev2## generic parallel device handler vector
000000r 3               
000000r 3               ; NOTE: OS rom self-test labels are not included in this file
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; Some misc. stuff from the 400/800 rev.B source
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               ; THE FOLLOWING ARE IN BASIC CARTRIDGE:
000000r 3               SIN     = $BD81         ;FR0 <- SIN (FR0) DEGFLG (0=RAD,6=DEG) CARRY
000000r 3               COS     = $BD73         ;FR0 <- COS (FR0) CARRY
000000r 3               ATAN    = $BE43         ;FR0 <- ATAN(FR0) CARRY
000000r 3               SQR     = $BEB1         ;FR0 <- ROOT(FR0) CARRY
000000r 3               
000000r 3               RADON   = 0             ;INDICATES RADIANS
000000r 3               DEGON   = 6             ;INDICATES DEGREES
000000r 3               
000000r 3               ASCZER  = '0'           ;ASCII ZERO
000000r 3               COLON   = $3A           ;ASCII COLON
000000r 3               CR      = $9B           ;SYSTEM EOL (CARRIAGE RETURN)
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; 6502
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               NMIVEC  = $FFFA
000000r 3               RESVEC  = $FFFC
000000r 3               IRQVEC  = $FFFE
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; BASIC
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               LOMEM   = $80           ;2-byte low memory pointer
000000r 3               VNTP    = $82           ;2-byte variable name table address
000000r 3               VNTD    = $84           ;2-byte variable name table end + 1
000000r 3               VVTP    = $86           ;2-byte variable value table
000000r 3               STMTAB  = $88           ;2-byte statement table address
000000r 3               STMCUR  = $8A           ;2-byte current statement pointer
000000r 3               STARP   = $8C           ;2-byte string and array table pointer
000000r 3               RUNSTK  = $8E           ;2-byte runtime stack address
000000r 3               BMEMTOP = $90           ;2-byte top of memory pointer
000000r 3               STOPLN  = $BA           ;2-byte stopped line number
000000r 3               ERRSAVE = $C3           ;1-byte error code
000000r 3               PTABW   = $C9           ;1-byte tab width
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; ATASCII CHARACTER DEFS
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               ATCLR   = $7D           ;CLEAR SCREEN CHARACTER
000000r 3               ATRUB   = $7E           ;BACK SPACE (RUBOUT)
000000r 3               ATTAB   = $7F           ;TAB
000000r 3               ATEOL   = $9B           ;END-OF-LINE
000000r 3               ATDELL  = $9C           ;delete line
000000r 3               ATINSL  = $9D           ;insert line
000000r 3               ATCTAB  = $9E           ;clear TAB
000000r 3               ATSTAB  = $9F           ;set TAB
000000r 3               ATBEL   = $FD           ;CONSOLE BELL
000000r 3               ATDEL   = $FE           ;delete char.
000000r 3               ATINS   = $FF           ;insert char.
000000r 3               ATURW   = $1C           ;UP-ARROW
000000r 3               ATDRW   = $1D           ;DOWN-ARROW
000000r 3               ATLRW   = $1E           ;LEFT-ARROW
000000r 3               ATRRW   = $1F           ;RIGHT-ARROW
000000r 3               ATESC   = $1B           ;ESCAPE
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; OFFSETS INTO SECTSIZETAB (DIO functions)
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               sst_flag     = 0        ; length 1
000000r 3               sst_sectsize = 1        ;        2
000000r 3               sst_driveno  = 3        ;        1  (drive #)
000000r 3               sst_size     = 4        ; size of one entry
000000r 3                                       ; if changed, adapt diopncls.s
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; OFFSETS INTO dio_phys_pos
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               diopp_head   = 0        ; head
000000r 3               diopp_track  = 1        ; track / cylinder
000000r 3               diopp_sector = 3        ; sector
000000r 3               diopp_size   = 5        ; size of structure
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; VALUES for dos_type
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               SPARTADOS    = 0
000000r 3               REALDOS      = 1
000000r 3               BWDOS        = 2
000000r 3               OSADOS       = 3        ; OS/A+
000000r 3               XDOS         = 4
000000r 3               ATARIDOS     = 5
000000r 3               MYDOS        = 6
000000r 3               NODOS        = 255
000000r 3               ; The DOSes with dos_type below or equal MAX_DOS_WITH_CMDLINE do support
000000r 3               ; command line arguments.
000000r 3               MAX_DOS_WITH_CMDLINE = XDOS
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; XDOS defines (version 2.4, taken from xdos24.pdf)
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 3               XOPT         = $070B    ; XDOS options
000000r 3               XCAR         = $070C    ; XDOS cartridge address (+ $70D)
000000r 3               XPAT         = $086F    ; XDOS bugfix and patch number
000000r 3               XVER         = $0870    ; XDOS version number
000000r 3               XFILE        = $087D    ; XDOS filename buffer
000000r 3               XLINE        = $0880    ; XDOS DUP input line
000000r 3               XGLIN        = $0871    ; get line
000000r 3               XSKIP        = $0874    ; skip parameter
000000r 3               .ifdef __ATARIXL__
000000r 3               .ifndef SHRAM_HANDLERS
000000r 3               .import XMOVE_handler
000000r 3               .endif
000000r 3               .define XMOVE XMOVE_handler
000000r 3               XMOVE_org    = $0877    ; move filename
000000r 3               .else
000000r 3               XMOVE        = $0877    ; move filename
000000r 3               .endif
000000r 3               XGNUM        = $087A    ; get number
000000r 3               
000000r 3               ;-------------------------------------------------------------------------
000000r 3               ; End of atari.inc
000000r 3               ;-------------------------------------------------------------------------
000000r 3               
000000r 2               RTCLOK1 = $13
000000r 2               RTCLOK2 = $14
000000r 2               .endif
000000r 2               
000000r 2               ; vi:syntax=asm_ca65
000000r 2               
000000r 1               
000000r 1               ; TOKENS:
000000r 1               	.importzp	TOK_0
000000r 1               	.importzp	TOK_1
000000r 1               	.importzp	TOK_ADD
000000r 1               	.importzp	TOK_ADD_VAR
000000r 1               	.importzp	TOK_BGET
000000r 1               	.importzp	TOK_BPUT
000000r 1               	.importzp	TOK_BYTE
000000r 1               	.importzp	TOK_BYTE_PEEK
000000r 1               	.importzp	TOK_BYTE_PUT
000000r 1               	.importzp	TOK_CALL
000000r 1               	.importzp	TOK_CAT_STR
000000r 1               	.importzp	TOK_CJUMP
000000r 1               	.importzp	TOK_CLOSE
000000r 1               	.importzp	TOK_CNJUMP
000000r 1               	.importzp	TOK_COMP_0
000000r 1               	.importzp	TOK_COPY_STR
000000r 1               	.importzp	TOK_CSTRING
000000r 1               	.importzp	TOK_DIM
000000r 1               	.importzp	TOK_DPEEK
000000r 1               	.importzp	TOK_DPOKE
000000r 1               	.importzp	TOK_END
000000r 1               	.importzp	TOK_EQ
000000r 1               	.importzp	TOK_FLOAT
000000r 1               	.importzp	TOK_FOR
000000r 1               	.importzp	TOK_FOR_EXIT
000000r 1               	.importzp	TOK_FOR_NEXT
000000r 1               	.importzp	TOK_FP_MUL
000000r 1               	.importzp	TOK_FP_STORE
000000r 1               	.importzp	TOK_GET
000000r 1               	.importzp	TOK_GETKEY
000000r 1               	.importzp	TOK_GT
000000r 1               	.importzp	TOK_INCVAR
000000r 1               	.importzp	TOK_INT_FP
000000r 1               	.importzp	TOK_INT_STR
000000r 1               	.importzp	TOK_IOCHN
000000r 1               	.importzp	TOK_JUMP
000000r 1               	.importzp	TOK_L_AND
000000r 1               	.importzp	TOK_L_NOT
000000r 1               	.importzp	TOK_L_OR
000000r 1               	.importzp	TOK_MOD
000000r 1               	.importzp	TOK_MUL6
000000r 1               	.importzp	TOK_NEQ
000000r 1               	.importzp	TOK_NUM
000000r 1               	.importzp	TOK_PAUSE
000000r 1               	.importzp	TOK_POKE
000000r 1               	.importzp	TOK_POP
000000r 1               	.importzp	TOK_PRINT_STR
000000r 1               	.importzp	TOK_PUSH
000000r 1               	.importzp	TOK_PUSH_0
000000r 1               	.importzp	TOK_PUSH_1
000000r 1               	.importzp	TOK_PUSH_BYTE
000000r 1               	.importzp	TOK_PUSH_NUM
000000r 1               	.importzp	TOK_PUSH_VAR_LOAD
000000r 1               	.importzp	TOK_RET
000000r 1               	.importzp	TOK_SADDR
000000r 1               	.importzp	TOK_SUB
000000r 1               	.importzp	TOK_USHL
000000r 1               	.importzp	TOK_VAR_ADDR
000000r 1               	.importzp	TOK_VAR_LOAD
000000r 1               	.importzp	TOK_VAR_SADDR
000000r 1               	.importzp	TOK_VAR_STORE
000000r 1               	.importzp	TOK_VAR_STORE_0
000000r 1               	.importzp	TOK_XIO
000000r 1               ;-----------------------------
000000r 1               ; Macro to get variable ID from name
000000r 1               	.import __HEAP_RUN__
000000r 1               .macro makevar name
000000r 1               	.byte <((.ident (.concat ("fb_var_", name)) - __HEAP_RUN__)/2)
000000r 1               .endmacro
000000r 1               ; Variables
000000r 1               	.segment "HEAP"
000000r 1               	.export fb_var_AA
000000r 1  xx xx xx xx  fb_var_AA:	.res 6	; Float variable
000004r 1  xx xx        
000006r 1               	.export fb_var_AB
000006r 1  xx xx xx xx  fb_var_AB:	.res 6	; Float variable
00000Ar 1  xx xx        
00000Cr 1               	.export fb_var_A
00000Cr 1  xx xx        fb_var_A:	.res 2	; Word variable
00000Er 1               	.export fb_var_B
00000Er 1  xx xx        fb_var_B:	.res 2	; Word variable
000010r 1               	.export fb_var_C4
000010r 1  xx xx        fb_var_C4:	.res 2	; Word Array variable
000012r 1               	.export fb_var_C5
000012r 1  xx xx        fb_var_C5:	.res 2	; Word Array variable
000014r 1               	.export fb_var_C6
000014r 1  xx xx        fb_var_C6:	.res 2	; Word Array variable
000016r 1               	.export fb_var_C5B
000016r 1  xx xx        fb_var_C5B:	.res 2	; Word Array variable
000018r 1               	.export fb_var_A4
000018r 1  xx xx        fb_var_A4:	.res 2	; Float Array variable
00001Ar 1               	.export fb_var_A5
00001Ar 1  xx xx        fb_var_A5:	.res 2	; Float Array variable
00001Cr 1               	.export fb_var_D2
00001Cr 1  xx xx        fb_var_D2:	.res 2	; Byte Array variable
00001Er 1               	.export fb_var_D3
00001Er 1  xx xx        fb_var_D3:	.res 2	; Byte Array variable
000020r 1               	.export fb_var_J4
000020r 1  xx xx        fb_var_J4:	.res 2	; String Array variable
000022r 1               	.export fb_var_J5
000022r 1  xx xx        fb_var_J5:	.res 2	; String Array variable
000024r 1               	.export fb_var_HW
000024r 1  xx xx        fb_var_HW:	.res 2	; String variable
000026r 1               	.export fb_var_I
000026r 1  xx xx        fb_var_I:	.res 2	; Word variable
000028r 1               	.export fb_var_MEM
000028r 1  xx xx        fb_var_MEM:	.res 2	; Word variable
00002Ar 1               	.export fb_var_SIZE
00002Ar 1  xx xx        fb_var_SIZE:	.res 2	; Word variable
00002Cr 1               	.export fb_var____DEBUG_ERR
00002Cr 1  xx xx        fb_var____DEBUG_ERR:	.res 2	; Word variable
00002Er 1               	.export fb_var____DEBUG_KEY
00002Er 1  xx xx        fb_var____DEBUG_KEY:	.res 2	; Word variable
000030r 1               	.export fb_var____DEBUG_MODE
000030r 1  xx xx        fb_var____DEBUG_MODE:	.res 2	; Word variable
000032r 1               	.export fb_var____DEBUG_MEM
000032r 1  xx xx        fb_var____DEBUG_MEM:	.res 2	; Word variable
000034r 1               	.export fb_var____DEBUG_LEN
000034r 1  xx xx        fb_var____DEBUG_LEN:	.res 2	; Word variable
000036r 1               	.export fb_var____DEBUG_LINE
000036r 1  xx xx        fb_var____DEBUG_LINE:	.res 2	; Word variable
000038r 1               	.export fb_var____DEBUG_MEMO
000038r 1  xx xx        fb_var____DEBUG_MEMO:	.res 2	; Word variable
00003Ar 1               ;-----------------------------
00003Ar 1               ; Bytecode
00003Ar 1               	.segment "BYTECODE"
000000r 1               bytecode_start:
000000r 1               @FastBasic_LINE_1:	; LINE 1
000000r 1  rr           	.byte	TOK_VAR_SADDR
000001r 1  rr           	makevar	"AA"
000002r 1  rr           	.byte	TOK_FLOAT
000003r 1  40 12 34 00  	.byte	$40, $12, $34, $00, $00, $00
000007r 1  00 00        
000009r 1  rr           	.byte	TOK_FP_STORE
00000Ar 1               @FastBasic_LINE_2:	; LINE 2
00000Ar 1  rr           	.byte	TOK_VAR_SADDR
00000Br 1  rr           	makevar	"AB"
00000Cr 1  rr           	.byte	TOK_FLOAT
00000Dr 1  40 56 78 00  	.byte	$40, $56, $78, $00, $00, $00
000011r 1  00 00        
000013r 1  rr           	.byte	TOK_FP_STORE
000014r 1               @FastBasic_LINE_4:	; LINE 4
000014r 1  rr           	.byte	TOK_1
000015r 1  rr           	.byte	TOK_VAR_STORE
000016r 1  rr           	makevar	"A"
000017r 1               @FastBasic_LINE_5:	; LINE 5
000017r 1  rr           	.byte	TOK_BYTE
000018r 1  05           	.byte	5
000019r 1  rr           	.byte	TOK_ADD_VAR
00001Ar 1  rr           	makevar	"A"
00001Br 1  rr           	.byte	TOK_VAR_STORE
00001Cr 1  rr           	makevar	"B"
00001Dr 1               @FastBasic_LINE_7:	; LINE 7
00001Dr 1  rr           	.byte	TOK_CSTRING
00001Er 1  04 58 59 5A  	.byte	4, "XYZ", 155
000022r 1  9B           
000023r 1  rr           	.byte	TOK_PRINT_STR
000024r 1               @FastBasic_LINE_8:	; LINE 8
000024r 1  rr           	.byte	TOK_BYTE
000025r 1  08           	.byte	8
000026r 1  rr           	.byte	TOK_DIM
000027r 1  rr           	makevar	"C4"
000028r 1  rr           	.byte	TOK_BYTE
000029r 1  0A           	.byte	10
00002Ar 1  rr           	.byte	TOK_DIM
00002Br 1  rr           	makevar	"C5"
00002Cr 1  rr           	.byte	TOK_BYTE
00002Dr 1  0C           	.byte	12
00002Er 1  rr           	.byte	TOK_DIM
00002Fr 1  rr           	makevar	"C6"
000030r 1  rr           	.byte	TOK_BYTE
000031r 1  0A           	.byte	10
000032r 1  rr           	.byte	TOK_DIM
000033r 1  rr           	makevar	"C5B"
000034r 1  rr           	.byte	TOK_BYTE
000035r 1  04           	.byte	4
000036r 1  rr           	.byte	TOK_MUL6
000037r 1  rr           	.byte	TOK_DIM
000038r 1  rr           	makevar	"A4"
000039r 1  rr           	.byte	TOK_BYTE
00003Ar 1  05           	.byte	5
00003Br 1  rr           	.byte	TOK_MUL6
00003Cr 1  rr           	.byte	TOK_DIM
00003Dr 1  rr           	makevar	"A5"
00003Er 1               @FastBasic_LINE_10:	; LINE 10
00003Er 1  rr           	.byte	TOK_BYTE
00003Fr 1  04           	.byte	4
000040r 1  rr           	.byte	TOK_ADD_VAR
000041r 1  rr           	makevar	"C4"
000042r 1  rr           	.byte	TOK_SADDR
000043r 1  rr           	.byte	TOK_BYTE
000044r 1  04           	.byte	4
000045r 1  rr           	.byte	TOK_DPOKE
000046r 1               @FastBasic_LINE_11:	; LINE 11
000046r 1  rr           	.byte	TOK_BYTE
000047r 1  06           	.byte	6
000048r 1  rr           	.byte	TOK_ADD_VAR
000049r 1  rr           	makevar	"C4"
00004Ar 1  rr           	.byte	TOK_SADDR
00004Br 1  rr           	.byte	TOK_BYTE
00004Cr 1  04           	.byte	4
00004Dr 1  rr           	.byte	TOK_ADD_VAR
00004Er 1  rr           	makevar	"C4"
00004Fr 1  rr           	.byte	TOK_DPEEK
000050r 1  rr           	.byte	TOK_USHL
000051r 1  rr           	.byte	TOK_DPOKE
000052r 1               @FastBasic_LINE_12:	; LINE 12
000052r 1  rr           	.byte	TOK_BYTE
000053r 1  02           	.byte	2
000054r 1  rr           	.byte	TOK_DIM
000055r 1  rr           	makevar	"D2"
000056r 1  rr           	.byte	TOK_BYTE
000057r 1  03           	.byte	3
000058r 1  rr           	.byte	TOK_DIM
000059r 1  rr           	makevar	"D3"
00005Ar 1               @FastBasic_LINE_14:	; LINE 14
00005Ar 1  rr           	.byte	TOK_BYTE
00005Br 1  08           	.byte	8
00005Cr 1  rr           	.byte	TOK_DIM
00005Dr 1  rr           	makevar	"J4"
00005Er 1  rr           	.byte	TOK_BYTE
00005Fr 1  0C           	.byte	12
000060r 1  rr           	.byte	TOK_DIM
000061r 1  rr           	makevar	"J5"
000062r 1               @FastBasic_LINE_15:	; LINE 15
000062r 1  rr           	.byte	TOK_VAR_SADDR
000063r 1  rr           	makevar	"HW"
000064r 1  rr           	.byte	TOK_CSTRING
000065r 1  19 48 65 6C  	.byte	25, "Hello World mister cowboy"
000069r 1  6C 6F 20 57  
00006Dr 1  6F 72 6C 64  
00007Fr 1  rr           	.byte	TOK_COPY_STR
000080r 1               @FastBasic_LINE_16:	; LINE 16
000080r 1  rr           	.byte	TOK_VAR_SADDR
000081r 1  rr           	makevar	"HW"
000082r 1  rr           	.byte	TOK_CSTRING
000083r 1  0B 48 65 6C  	.byte	11, "Hello World"
000087r 1  6C 6F 20 57  
00008Br 1  6F 72 6C 64  
00008Fr 1  rr           	.byte	TOK_COPY_STR
000090r 1               @FastBasic_LINE_18:	; LINE 18
000090r 1  rr           	.byte	TOK_VAR_LOAD
000091r 1  rr           	makevar	"HW"
000092r 1  rr           	.byte	TOK_PRINT_STR
000093r 1  rr           	.byte	TOK_BYTE_PUT
000094r 1  9B           	.byte	155
000095r 1               @FastBasic_LINE_19:	; LINE 19
000095r 1  rr           	.byte	TOK_VAR_LOAD
000096r 1  rr           	makevar	"D3"
000097r 1  rr           	.byte	TOK_SADDR
000098r 1  rr           	.byte	TOK_BYTE
000099r 1  02           	.byte	2
00009Ar 1  rr           	.byte	TOK_POKE
00009Br 1  rr           	.byte	TOK_1
00009Cr 1  rr           	.byte	TOK_ADD_VAR
00009Dr 1  rr           	makevar	"D3"
00009Er 1  rr           	.byte	TOK_SADDR
00009Fr 1  rr           	.byte	TOK_BYTE
0000A0r 1  64           	.byte	100
0000A1r 1  rr           	.byte	TOK_POKE
0000A2r 1               @FastBasic_LINE_20:	; LINE 20
0000A2r 1  rr           	.byte	TOK_VAR_SADDR
0000A3r 1  rr           	makevar	"I"
0000A4r 1  rr           	.byte	TOK_PUSH_0
0000A5r 1  rr           	.byte	TOK_DPOKE
0000A6r 1  rr           	.byte	TOK_BYTE
0000A7r 1  03           	.byte	3
0000A8r 1  rr           	.byte	TOK_PUSH_1
0000A9r 1  rr           	.byte	TOK_FOR
0000AAr 1  rr           	.byte	TOK_CNJUMP
0000ABr 1  rr rr        	.word	jump_lbl_1
0000ADr 1               jump_lbl_2:
0000ADr 1               @FastBasic_LINE_21:	; LINE 21
0000ADr 1  rr           	.byte	TOK_VAR_LOAD
0000AEr 1  rr           	makevar	"I"
0000AFr 1  rr           	.byte	TOK_USHL
0000B0r 1  rr           	.byte	TOK_ADD_VAR
0000B1r 1  rr           	makevar	"J4"
0000B2r 1  rr           	.byte	TOK_SADDR
0000B3r 1  rr           	.byte	TOK_CSTRING
0000B4r 1  0F 74 65 73  	.byte	15, "test-j4-string-"
0000B8r 1  74 2D 6A 34  
0000BCr 1  2D 73 74 72  
0000C4r 1  rr           	.byte	TOK_COPY_STR
0000C5r 1  rr           	.byte	TOK_VAR_LOAD
0000C6r 1  rr           	makevar	"I"
0000C7r 1  rr           	.byte	TOK_USHL
0000C8r 1  rr           	.byte	TOK_ADD_VAR
0000C9r 1  rr           	makevar	"J4"
0000CAr 1  rr           	.byte	TOK_SADDR
0000CBr 1  rr           	.byte	TOK_VAR_LOAD
0000CCr 1  rr           	makevar	"I"
0000CDr 1  rr           	.byte	TOK_INT_STR
0000CEr 1  rr           	.byte	TOK_CAT_STR
0000CFr 1               @FastBasic_LINE_22:	; LINE 22
0000CFr 1  rr           	.byte	TOK_VAR_LOAD
0000D0r 1  rr           	makevar	"I"
0000D1r 1  rr           	.byte	TOK_USHL
0000D2r 1  rr           	.byte	TOK_ADD_VAR
0000D3r 1  rr           	makevar	"J5"
0000D4r 1  rr           	.byte	TOK_SADDR
0000D5r 1  rr           	.byte	TOK_CSTRING
0000D6r 1  0F 74 65 73  	.byte	15, "test-j5-string-"
0000DAr 1  74 2D 6A 35  
0000DEr 1  2D 73 74 72  
0000E6r 1  rr           	.byte	TOK_COPY_STR
0000E7r 1  rr           	.byte	TOK_VAR_LOAD
0000E8r 1  rr           	makevar	"I"
0000E9r 1  rr           	.byte	TOK_USHL
0000EAr 1  rr           	.byte	TOK_ADD_VAR
0000EBr 1  rr           	makevar	"J5"
0000ECr 1  rr           	.byte	TOK_SADDR
0000EDr 1  rr           	.byte	TOK_VAR_LOAD
0000EEr 1  rr           	makevar	"I"
0000EFr 1  rr           	.byte	TOK_INT_STR
0000F0r 1  rr           	.byte	TOK_CAT_STR
0000F1r 1               @FastBasic_LINE_23:	; LINE 23
0000F1r 1  rr           	.byte	TOK_VAR_LOAD
0000F2r 1  rr           	makevar	"A4"
0000F3r 1  rr           	.byte	TOK_PUSH_VAR_LOAD
0000F4r 1  rr           	makevar	"I"
0000F5r 1  rr           	.byte	TOK_MUL6
0000F6r 1  rr           	.byte	TOK_ADD
0000F7r 1  rr           	.byte	TOK_SADDR
0000F8r 1  rr           	.byte	TOK_FLOAT
0000F9r 1  3F 33 30 00  	.byte	$3F, $33, $30, $00, $00, $00
0000FDr 1  00 00        
0000FFr 1  rr           	.byte	TOK_VAR_LOAD
000100r 1  rr           	makevar	"I"
000101r 1  rr           	.byte	TOK_INT_FP
000102r 1  rr           	.byte	TOK_FP_MUL
000103r 1  rr           	.byte	TOK_FP_STORE
000104r 1               @FastBasic_LINE_24:	; LINE 24
000104r 1  rr           	.byte	TOK_FOR_NEXT
000105r 1  rr           	.byte	TOK_CJUMP
000106r 1  rr rr        	.word	jump_lbl_2
000108r 1               jump_lbl_1:
000108r 1  rr           	.byte	TOK_FOR_EXIT
000109r 1               @FastBasic_LINE_26:	; LINE 26
000109r 1  rr           	.byte	TOK_BYTE
00010Ar 1  0A           	.byte	10
00010Br 1  rr           	.byte	TOK_ADD_VAR
00010Cr 1  rr           	makevar	"J5"
00010Dr 1  rr           	.byte	TOK_SADDR
00010Er 1  rr           	.byte	TOK_CSTRING
00010Fr 1  0D 54 45 53  	.byte	13, "TEST-5-MANUAL"
000113r 1  54 2D 35 2D  
000117r 1  4D 41 4E 55  
00011Dr 1  rr           	.byte	TOK_COPY_STR
00011Er 1               @FastBasic_LINE_27:	; LINE 27
00011Er 1  rr           	.byte	TOK_BYTE
00011Fr 1  08           	.byte	8
000120r 1  rr           	.byte	TOK_ADD_VAR
000121r 1  rr           	makevar	"J5"
000122r 1  rr           	.byte	TOK_SADDR
000123r 1  rr           	.byte	TOK_CSTRING
000124r 1  0D 54 45 53  	.byte	13, "TEST-4-MANUAL"
000128r 1  54 2D 34 2D  
00012Cr 1  4D 41 4E 55  
000132r 1  rr           	.byte	TOK_COPY_STR
000133r 1               @FastBasic_LINE_28:	; LINE 28
000133r 1  rr           	.byte	TOK_CSTRING
000134r 1  03 69 3A 20  	.byte	3, "i: "
000138r 1  rr           	.byte	TOK_PRINT_STR
000139r 1  rr           	.byte	TOK_VAR_LOAD
00013Ar 1  rr           	makevar	"I"
00013Br 1  rr           	.byte	TOK_INT_STR
00013Cr 1  rr           	.byte	TOK_PRINT_STR
00013Dr 1  rr           	.byte	TOK_CSTRING
00013Er 1  03 20 40 20  	.byte	3, " @ "
000142r 1  rr           	.byte	TOK_PRINT_STR
000143r 1  rr           	.byte	TOK_VAR_ADDR
000144r 1  rr           	makevar	"I"
000145r 1  rr           	.byte	TOK_INT_STR
000146r 1  rr           	.byte	TOK_PRINT_STR
000147r 1  rr           	.byte	TOK_BYTE_PUT
000148r 1  9B           	.byte	155
000149r 1               @FastBasic_LINE_40:	; LINE 40
000149r 1  rr           	.byte	TOK_1
00014Ar 1  rr           	.byte	TOK_PUSH
00014Br 1  rr           	.byte	TOK_CALL
00014Cr 1  rr rr        	.word	fb_lbl____DEBUG_BP
00014Er 1               @FastBasic_LINE_41:	; LINE 41
00014Er 1  rr           	.byte	TOK_GETKEY
00014Fr 1  rr           	.byte	TOK_VAR_STORE
000150r 1  rr           	makevar	"___DEBUG_KEY"
000151r 1               @FastBasic_LINE_42:	; LINE 42
000151r 1  rr           	.byte	TOK_END
000152r 1               @FastBasic_LINE_45:	; LINE 45
000152r 1               	.segment "BYTECODE"
000152r 1               	.export	fb_lbl____DEBUG_BP
000152r 1               fb_lbl____DEBUG_BP:
000152r 1  rr           	.byte	TOK_POP
000153r 1  rr           	.byte	TOK_VAR_STORE
000154r 1  rr           	makevar	"___DEBUG_LINE"
000155r 1               @FastBasic_LINE_46:	; LINE 46
000155r 1  rr           	.byte	TOK_CSTRING
000156r 1  0D 5B 42 52  	.byte	13, "[BREAKPOINT]", 155
00015Ar 1  45 41 4B 50  
00015Er 1  4F 49 4E 54  
000164r 1  rr           	.byte	TOK_PRINT_STR
000165r 1               @FastBasic_LINE_48:	; LINE 48
000165r 1  rr           	.byte	TOK_BYTE
000166r 1  05           	.byte	5
000167r 1  rr           	.byte	TOK_CLOSE
000168r 1               @FastBasic_LINE_49:	; LINE 49
000168r 1               jump_lbl_7:
000168r 1               @FastBasic_LINE_50:	; LINE 50
000168r 1  rr           	.byte	TOK_BYTE
000169r 1  05           	.byte	5
00016Ar 1  rr           	.byte	TOK_PUSH_BYTE
00016Br 1  03           	.byte	3
00016Cr 1  rr           	.byte	TOK_PUSH_BYTE
00016Dr 1  04           	.byte	4
00016Er 1  rr           	.byte	TOK_PUSH
00016Fr 1  rr           	.byte	TOK_CSTRING
000170r 1  0B 48 34 3A  	.byte	11, "H4:debug.in"
000174r 1  64 65 62 75  
000178r 1  67 2E 69 6E  
00017Cr 1  rr           	.byte	TOK_XIO
00017Dr 1               @FastBasic_LINE_51:	; LINE 51
00017Dr 1  rr           	.byte	TOK_BYTE_PEEK
00017Er 1  rr           	.byte	IOERROR
00017Fr 1  rr           	.byte	TOK_PUSH_1
000180r 1  rr           	.byte	TOK_EQ
000181r 1  rr           	.byte	TOK_CJUMP
000182r 1  rr rr        	.word	jump_lbl_8
000184r 1               @FastBasic_LINE_52:	; LINE 52
000184r 1  rr           	.byte	TOK_BYTE
000185r 1  05           	.byte	5
000186r 1  rr           	.byte	TOK_IOCHN
000187r 1  rr           	.byte	TOK_GET
000188r 1  rr           	.byte	TOK_VAR_STORE
000189r 1  rr           	makevar	"___DEBUG_MODE"
00018Ar 1  rr           	.byte	TOK_0
00018Br 1  rr           	.byte	TOK_IOCHN
00018Cr 1               @FastBasic_LINE_53:	; LINE 53
00018Cr 1  rr           	.byte	TOK_CSTRING
00018Dr 1  0C 5B 44 45  	.byte	12, "[DEBUG MODE "
000191r 1  42 55 47 20  
000195r 1  4D 4F 44 45  
00019Ar 1  rr           	.byte	TOK_PRINT_STR
00019Br 1  rr           	.byte	TOK_VAR_LOAD
00019Cr 1  rr           	makevar	"___DEBUG_MODE"
00019Dr 1  rr           	.byte	TOK_INT_STR
00019Er 1  rr           	.byte	TOK_PRINT_STR
00019Fr 1               @FastBasic_LINE_54:	; LINE 54
00019Fr 1  rr           	.byte	TOK_BYTE_PUT
0001A0r 1  5D           	.byte	93
0001A1r 1  rr           	.byte	TOK_BYTE_PUT
0001A2r 1  9B           	.byte	155
0001A3r 1  rr           	.byte	TOK_VAR_LOAD
0001A4r 1  rr           	makevar	"___DEBUG_MODE"
0001A5r 1  rr           	.byte	TOK_COMP_0
0001A6r 1  rr           	.byte	TOK_L_NOT
0001A7r 1  rr           	.byte	TOK_PUSH
0001A8r 1  rr           	.byte	TOK_BYTE_PEEK
0001A9r 1  rr           	.byte	IOERROR
0001AAr 1  rr           	.byte	TOK_PUSH_1
0001ABr 1  rr           	.byte	TOK_NEQ
0001ACr 1  rr           	.byte	TOK_L_OR
0001ADr 1  rr           	.byte	TOK_CNJUMP
0001AEr 1  rr rr        	.word	jump_lbl_7_x
0001B0r 1               @FastBasic_LINE_56:	; LINE 56
0001B0r 1  rr           	.byte	TOK_VAR_LOAD
0001B1r 1  rr           	makevar	"___DEBUG_MODE"
0001B2r 1  rr           	.byte	TOK_PUSH_BYTE
0001B3r 1  02           	.byte	2
0001B4r 1  rr           	.byte	TOK_EQ
0001B5r 1  rr           	.byte	TOK_CJUMP
0001B6r 1  rr rr        	.word	jump_lbl_10
0001B8r 1               @FastBasic_LINE_58:	; LINE 58
0001B8r 1  rr           	.byte	TOK_BYTE
0001B9r 1  04           	.byte	4
0001BAr 1  rr           	.byte	TOK_CLOSE
0001BBr 1  rr           	.byte	TOK_BYTE
0001BCr 1  04           	.byte	4
0001BDr 1  rr           	.byte	TOK_PUSH_BYTE
0001BEr 1  03           	.byte	3
0001BFr 1  rr           	.byte	TOK_PUSH_BYTE
0001C0r 1  08           	.byte	8
0001C1r 1  rr           	.byte	TOK_PUSH
0001C2r 1  rr           	.byte	TOK_CSTRING
0001C3r 1  0C 48 34 3A  	.byte	12, "H4:debug.out"
0001C7r 1  64 65 62 75  
0001CBr 1  67 2E 6F 75  
0001D0r 1  rr           	.byte	TOK_XIO
0001D1r 1               @FastBasic_LINE_59:	; LINE 59
0001D1r 1               jump_lbl_11:
0001D1r 1               @FastBasic_LINE_61:	; LINE 61
0001D1r 1  rr           	.byte	TOK_VAR_STORE_0
0001D2r 1  rr           	makevar	"___DEBUG_MEM"
0001D3r 1  rr           	.byte	TOK_BYTE
0001D4r 1  05           	.byte	5
0001D5r 1  rr           	.byte	TOK_PUSH
0001D6r 1  rr           	.byte	TOK_VAR_ADDR
0001D7r 1  rr           	makevar	"___DEBUG_MEM"
0001D8r 1  rr           	.byte	TOK_PUSH_BYTE
0001D9r 1  04           	.byte	4
0001DAr 1  rr           	.byte	TOK_BGET
0001DBr 1  rr           	.byte	TOK_VAR_LOAD
0001DCr 1  rr           	makevar	"___DEBUG_MEM"
0001DDr 1  rr           	.byte	TOK_COMP_0
0001DEr 1  rr           	.byte	TOK_CJUMP
0001DFr 1  rr rr        	.word	jump_lbl_11_x
0001E1r 1               @FastBasic_LINE_66:	; LINE 66
0001E1r 1  rr           	.byte	TOK_VAR_LOAD
0001E2r 1  rr           	makevar	"___DEBUG_MEM"
0001E3r 1  rr           	.byte	TOK_VAR_STORE
0001E4r 1  rr           	makevar	"___DEBUG_MEMO"
0001E5r 1               @FastBasic_LINE_67:	; LINE 67
0001E5r 1  rr           	.byte	TOK_VAR_LOAD
0001E6r 1  rr           	makevar	"___DEBUG_MODE"
0001E7r 1  rr           	.byte	TOK_PUSH_NUM
0001E8r 1  EA 03        	.word	1002
0001EAr 1  rr           	.byte	TOK_EQ
0001EBr 1  rr           	.byte	TOK_CJUMP
0001ECr 1  rr rr        	.word	jump_lbl_13
0001EEr 1  rr           	.byte	TOK_VAR_LOAD
0001EFr 1  rr           	makevar	"___DEBUG_MEM"
0001F0r 1  rr           	.byte	TOK_DPEEK
0001F1r 1  rr           	.byte	TOK_VAR_STORE
0001F2r 1  rr           	makevar	"___DEBUG_MEM"
0001F3r 1               jump_lbl_13:
0001F3r 1               @FastBasic_LINE_68:	; LINE 68
0001F3r 1  rr           	.byte	TOK_NUM
0001F4r 1  EA 03        	.word	1002
0001F6r 1  rr           	.byte	TOK_VAR_STORE
0001F7r 1  rr           	makevar	"___DEBUG_MODE"
0001F8r 1               @FastBasic_LINE_71:	; LINE 71
0001F8r 1  rr           	.byte	TOK_VAR_LOAD
0001F9r 1  rr           	makevar	"___DEBUG_LEN"
0001FAr 1  rr           	.byte	TOK_PUSH_NUM
0001FBr 1  00 01        	.word	256
0001FDr 1  rr           	.byte	TOK_MOD
0001FEr 1  rr           	.byte	TOK_COMP_0
0001FFr 1  rr           	.byte	TOK_L_NOT
000200r 1  rr           	.byte	TOK_PUSH_VAR_LOAD
000201r 1  rr           	makevar	"___DEBUG_LEN"
000202r 1  rr           	.byte	TOK_PUSH_NUM
000203r 1  00 01        	.word	256
000205r 1  rr           	.byte	TOK_GT
000206r 1  rr           	.byte	TOK_L_AND
000207r 1  rr           	.byte	TOK_CJUMP
000208r 1  rr rr        	.word	jump_lbl_14
00020Ar 1               @FastBasic_LINE_72:	; LINE 72
00020Ar 1               jump_lbl_15:
00020Ar 1  rr           	.byte	TOK_VAR_LOAD
00020Br 1  rr           	makevar	"___DEBUG_LEN"
00020Cr 1  rr           	.byte	TOK_PUSH_0
00020Dr 1  rr           	.byte	TOK_GT
00020Er 1  rr           	.byte	TOK_CJUMP
00020Fr 1  rr rr        	.word	jump_lbl_11
000211r 1               @FastBasic_LINE_74:	; LINE 74
000211r 1  rr           	.byte	TOK_BYTE
000212r 1  04           	.byte	4
000213r 1  rr           	.byte	TOK_PUSH_VAR_LOAD
000214r 1  rr           	makevar	"___DEBUG_MEM"
000215r 1  rr           	.byte	TOK_DPEEK
000216r 1  rr           	.byte	TOK_PUSH_NUM
000217r 1  00 01        	.word	256
000219r 1  rr           	.byte	TOK_BPUT
00021Ar 1               @FastBasic_LINE_75:	; LINE 75
00021Ar 1  rr           	.byte	TOK_INCVAR
00021Br 1  rr           	makevar	"___DEBUG_MEM"
00021Cr 1  rr           	.byte	TOK_INCVAR
00021Dr 1  rr           	makevar	"___DEBUG_MEM"
00021Er 1               @FastBasic_LINE_76:	; LINE 76
00021Er 1  rr           	.byte	TOK_VAR_LOAD
00021Fr 1  rr           	makevar	"___DEBUG_LEN"
000220r 1  rr           	.byte	TOK_PUSH_NUM
000221r 1  00 01        	.word	256
000223r 1  rr           	.byte	TOK_SUB
000224r 1  rr           	.byte	TOK_VAR_STORE
000225r 1  rr           	makevar	"___DEBUG_LEN"
000226r 1               @FastBasic_LINE_77:	; LINE 77
000226r 1  rr           	.byte	TOK_JUMP
000227r 1  rr rr        	.word	jump_lbl_15
000229r 1               @FastBasic_LINE_78:	; LINE 78
000229r 1               jump_lbl_14:
000229r 1               @FastBasic_LINE_80:	; LINE 80
000229r 1  rr           	.byte	TOK_BYTE
00022Ar 1  04           	.byte	4
00022Br 1  rr           	.byte	TOK_PUSH_VAR_LOAD
00022Cr 1  rr           	makevar	"___DEBUG_MEM"
00022Dr 1  rr           	.byte	TOK_PUSH_VAR_LOAD
00022Er 1  rr           	makevar	"___DEBUG_LEN"
00022Fr 1  rr           	.byte	TOK_BPUT
000230r 1               @FastBasic_LINE_88:	; LINE 88
000230r 1  rr           	.byte	TOK_JUMP
000231r 1  rr rr        	.word	jump_lbl_11
000233r 1               jump_lbl_11_x:
000233r 1               @FastBasic_LINE_89:	; LINE 89
000233r 1  rr           	.byte	TOK_BYTE
000234r 1  04           	.byte	4
000235r 1  rr           	.byte	TOK_CLOSE
000236r 1               @FastBasic_LINE_90:	; LINE 90
000236r 1  rr           	.byte	TOK_JUMP
000237r 1  rr rr        	.word	jump_lbl_18
000239r 1               jump_lbl_10:
000239r 1  rr           	.byte	TOK_VAR_LOAD
00023Ar 1  rr           	makevar	"___DEBUG_MODE"
00023Br 1  rr           	.byte	TOK_PUSH_BYTE
00023Cr 1  03           	.byte	3
00023Dr 1  rr           	.byte	TOK_EQ
00023Er 1  rr           	.byte	TOK_CJUMP
00023Fr 1  rr rr        	.word	jump_lbl_18
000241r 1               @FastBasic_LINE_92:	; LINE 92
000241r 1               jump_lbl_18:
000241r 1               @FastBasic_LINE_93:	; LINE 93
000241r 1  rr           	.byte	TOK_BYTE
000242r 1  05           	.byte	5
000243r 1  rr           	.byte	TOK_CLOSE
000244r 1               @FastBasic_LINE_94:	; LINE 94
000244r 1  rr           	.byte	TOK_BYTE
000245r 1  05           	.byte	5
000246r 1  rr           	.byte	TOK_PUSH_BYTE
000247r 1  21           	.byte	33
000248r 1  rr           	.byte	TOK_PUSH_0
000249r 1  rr           	.byte	TOK_PUSH
00024Ar 1  rr           	.byte	TOK_CSTRING
00024Br 1  0B 48 34 3A  	.byte	11, "H4:debug.in"
00024Fr 1  64 65 62 75  
000253r 1  67 2E 69 6E  
000257r 1  rr           	.byte	TOK_XIO
000258r 1               @FastBasic_LINE_96:	; LINE 96
000258r 1               jump_lbl_8:
000258r 1               @FastBasic_LINE_97:	; LINE 97
000258r 1  rr           	.byte	TOK_BYTE
000259r 1  0A           	.byte	10
00025Ar 1  rr           	.byte	TOK_PAUSE
00025Br 1               @FastBasic_LINE_98:	; LINE 98
00025Br 1  rr           	.byte	TOK_JUMP
00025Cr 1  rr rr        	.word	jump_lbl_7
00025Er 1               jump_lbl_7_x:
00025Er 1               @FastBasic_LINE_100:	; LINE 100
00025Er 1  rr           	.byte	TOK_CSTRING
00025Fr 1  09 5B 52 45  	.byte	9, "[RESUME]", 155
000263r 1  53 55 4D 45  
000267r 1  5D 9B        
000269r 1  rr           	.byte	TOK_PRINT_STR
00026Ar 1               @FastBasic_LINE_101:	; LINE 101
00026Ar 1  rr           	.byte	TOK_RET
00026Ar 1               
